package exploit

import (
	"fmt"
	"strings"

	"github.com/fatih/color"
)

// DisplayColors for output
var (
	colorCyan    = color.New(color.FgCyan).SprintFunc()
	colorGreen   = color.New(color.FgGreen).SprintFunc()
	colorYellow  = color.New(color.FgYellow).SprintFunc()
	colorRed     = color.New(color.FgRed).SprintFunc()
	colorMagenta = color.New(color.FgMagenta).SprintFunc()
	colorWhite   = color.New(color.FgWhite).SprintFunc()
	colorBold    = color.New(color.Bold).SprintFunc()
)

// DisplaySubdomainHeader shows subdomain header with colored dot and status
func DisplaySubdomainHeader(subdomain string, statusCode int) {
	dot := colorGreen("●")
	if statusCode >= 400 {
		dot = colorRed("●")
	} else if statusCode >= 300 {
		dot = colorYellow("●")
	}

	fmt.Printf("\n%s %s [%d]\n", dot, colorBold(subdomain), statusCode)
}

// DisplayTestHeader shows the current test being run
func DisplayTestHeader(testName string) {
	fmt.Printf("\n  %s Testing %s...\n", colorCyan("→"), colorBold(testName))
}

// DisplayPayload shows a payload being tested
func DisplayPayload(payload string, index, total int) {
	fmt.Printf("    %s Payload %d/%d: %s\n",
		colorYellow("↳"),
		index,
		total,
		colorWhite(truncate(payload, 80)),
	)
}

// DisplayAIReasoning shows AI's thought process
func DisplayAIReasoning(reasoning string) {
	fmt.Printf("      %s AI: %s\n",
		colorMagenta("ℹ"),
		colorWhite(reasoning),
	)
}

// DisplayWAFDetected shows WAF detection
func DisplayWAFDetected(wafType string) {
	fmt.Printf("      %s WAF detected: %s\n",
		colorRed("⚠"),
		colorYellow(wafType),
	)
}

// DisplayBypassAttempt shows bypass technique being tried
func DisplayBypassAttempt(technique string) {
	fmt.Printf("      %s Trying bypass: %s\n",
		colorCyan("⟳"),
		colorWhite(technique),
	)
}

// DisplaySuccess shows successful exploit
func DisplaySuccess(vulnType VulnerabilityType, evidence string) {
	fmt.Printf("    %s %s %s found!\n",
		colorGreen("✓"),
		colorBold(string(vulnType)),
		colorGreen("vulnerability"),
	)
	fmt.Printf("      %s Evidence: %s\n",
		colorGreen("→"),
		colorWhite(truncate(evidence, 100)),
	)
}

// DisplayFailure shows failed attempt
func DisplayFailure(reason string) {
	fmt.Printf("    %s %s\n",
		colorRed("✗"),
		colorWhite(reason),
	)
}

// DisplayJSAnalysisResults shows Deep JS Analysis results
func DisplayJSAnalysisResults(result *JSAnalysisResult) {
	if result == nil {
		fmt.Printf("    %s No JavaScript files found\n", colorRed("✗"))
		return
	}

	fmt.Printf("    %s Found %d JavaScript file(s)\n",
		colorGreen("✓"),
		len(result.JSFiles),
	)

	// Display secrets
	if len(result.Secrets) > 0 {
		fmt.Printf("\n      %s Secrets Found: %d\n",
			colorRed("⚠"),
			len(result.Secrets),
		)
		for _, secret := range result.Secrets {
			fmt.Printf("        %s %s: %s (line %d)\n",
				colorRed("→"),
				colorBold(secret.SecretType),
				colorYellow(secret.Value),
				secret.LineNumber,
			)
			if secret.Context != "" {
				lines := strings.Split(secret.Context, "\n")
				for _, line := range lines {
					fmt.Printf("          %s\n", colorWhite(line))
				}
			}
		}
	}

	// Display API endpoints
	if len(result.APIEndpoints) > 0 {
		fmt.Printf("\n      %s API Endpoints Found: %d\n",
			colorCyan("ℹ"),
			len(result.APIEndpoints),
		)
		for _, endpoint := range result.APIEndpoints {
			fmt.Printf("        %s %s %s (line %d)\n",
				colorCyan("→"),
				colorBold(endpoint.Method),
				colorWhite(endpoint.Endpoint),
				endpoint.LineNumber,
			)
		}
	}

	// Display hidden parameters
	if len(result.HiddenParams) > 0 {
		fmt.Printf("\n      %s Hidden Parameters Found: %d\n",
			colorYellow("ℹ"),
			len(result.HiddenParams),
		)
		paramList := strings.Join(result.HiddenParams, ", ")
		fmt.Printf("        %s\n", colorWhite(truncate(paramList, 100)))
	}

	// Display auth logic flaws
	if len(result.AuthLogicFlaws) > 0 {
		fmt.Printf("\n      %s Auth Logic Flaws Found: %d\n",
			colorRed("⚠"),
			len(result.AuthLogicFlaws),
		)
		for _, flaw := range result.AuthLogicFlaws {
			fmt.Printf("        %s %s\n",
				colorRed("→"),
				colorWhite(flaw),
			)
		}
	}

	// Display sensitive comments
	if len(result.SensitiveComments) > 0 {
		fmt.Printf("\n      %s Sensitive Comments Found: %d\n",
			colorYellow("ℹ"),
			len(result.SensitiveComments),
		)
		for i, comment := range result.SensitiveComments {
			if i < 3 { // Show only first 3
				fmt.Printf("        %s %s\n",
					colorYellow("→"),
					colorWhite(truncate(comment, 80)),
				)
			}
		}
		if len(result.SensitiveComments) > 3 {
			fmt.Printf("        %s ... and %d more\n",
				colorYellow("→"),
				len(result.SensitiveComments)-3,
			)
		}
	}

	if len(result.Secrets) == 0 && len(result.APIEndpoints) == 0 &&
		len(result.HiddenParams) == 0 && len(result.AuthLogicFlaws) == 0 &&
		len(result.SensitiveComments) == 0 {
		fmt.Printf("      %s No sensitive information found in JS files\n", colorYellow("ℹ"))
	}
}

// DisplayExploit shows full exploit details
func DisplayExploit(exploit *Exploit) {
	fmt.Printf("\n  %s %s Exploit Found!\n",
		colorGreen("✓"),
		colorBold(string(exploit.VulnType)),
	)

	fmt.Printf("    %s URL: %s\n",
		colorCyan("→"),
		colorWhite(exploit.URL),
	)

	fmt.Printf("    %s Severity: %s\n",
		colorCyan("→"),
		getSeverityColor(exploit.Severity)(exploit.Severity),
	)

	fmt.Printf("    %s Payload: %s\n",
		colorCyan("→"),
		colorYellow(exploit.Payload),
	)

	fmt.Printf("    %s Method: %s\n",
		colorCyan("→"),
		colorWhite(exploit.Method),
	)

	if exploit.BypassUsed != "" {
		fmt.Printf("    %s Bypass Technique: %s\n",
			colorMagenta("→"),
			colorWhite(exploit.BypassUsed),
		)
	}

	fmt.Printf("    %s Evidence: %s\n",
		colorGreen("→"),
		colorWhite(truncate(exploit.Evidence, 100)),
	)

	if exploit.ExtractedData != "" {
		fmt.Printf("    %s Extracted Data: %s\n",
			colorYellow("→"),
			colorWhite(exploit.ExtractedData),
		)
	}

	fmt.Printf("    %s Impact: %s\n",
		colorRed("→"),
		colorWhite(exploit.Impact),
	)

	if exploit.AIReasoning != "" {
		fmt.Printf("    %s AI Analysis: %s\n",
			colorMagenta("→"),
			colorWhite(truncate(exploit.AIReasoning, 100)),
		)
	}

	if exploit.ExploitFile != "" {
		fmt.Printf("    %s Exploit saved to: %s\n",
			colorGreen("→"),
			colorCyan(exploit.ExploitFile),
		)
	}
}

// DisplaySubdomainSummary shows summary for a subdomain
func DisplaySubdomainSummary(result *SubdomainResult) {
	fmt.Printf("\n  %s Summary for %s:\n",
		colorBold("━"),
		colorBold(result.Subdomain),
	)

	if result.JSAnalysis != nil {
		fmt.Printf("    • JS Files Analyzed: %d\n", len(result.JSAnalysis.JSFiles))
		fmt.Printf("    • Secrets Found: %d\n", len(result.JSAnalysis.Secrets))
	}

	fmt.Printf("    • Total Exploits Found: %s\n",
		getSeverityColor(getOverallSeverity(result.Exploits))(fmt.Sprintf("%d", result.TotalExploits)),
	)

	if result.TotalExploits > 0 {
		// Group by vulnerability type
		vulnCounts := make(map[VulnerabilityType]int)
		for _, exploit := range result.Exploits {
			vulnCounts[exploit.VulnType]++
		}

		for vulnType, count := range vulnCounts {
			fmt.Printf("      %s %s: %d\n",
				colorCyan("→"),
				vulnType,
				count,
			)
		}
	}
}

// DisplayFinalSummary shows final summary for all subdomains
func DisplayFinalSummary(results []*SubdomainResult) {
	fmt.Printf("\n%s\n", strings.Repeat("=", 60))
	fmt.Printf("%s %s\n", colorBold("━━"), colorBold("Phase 7: Active Exploitation Summary"))
	fmt.Printf("%s\n\n", strings.Repeat("=", 60))

	totalSubdomains := len(results)
	totalExploits := 0
	totalSecrets := 0
	vulnCounts := make(map[VulnerabilityType]int)

	for _, result := range results {
		totalExploits += result.TotalExploits

		if result.JSAnalysis != nil {
			totalSecrets += len(result.JSAnalysis.Secrets)
		}

		for _, exploit := range result.Exploits {
			vulnCounts[exploit.VulnType]++
		}
	}

	fmt.Printf("  %s Subdomains Tested: %s\n",
		colorCyan("→"),
		colorBold(fmt.Sprintf("%d", totalSubdomains)),
	)

	fmt.Printf("  %s Total Vulnerabilities Found: %s\n",
		colorGreen("→"),
		colorBold(fmt.Sprintf("%d", totalExploits)),
	)

	if totalSecrets > 0 {
		fmt.Printf("  %s Secrets Discovered: %s\n",
			colorRed("→"),
			colorBold(fmt.Sprintf("%d", totalSecrets)),
		)
	}

	if len(vulnCounts) > 0 {
		fmt.Printf("\n  %s Vulnerabilities by Type:\n", colorBold("Breakdown:"))
		for vulnType, count := range vulnCounts {
			fmt.Printf("    • %s: %s\n",
				vulnType,
				getSeverityColor("high")(fmt.Sprintf("%d", count)),
			)
		}
	}

	fmt.Printf("\n%s\n", strings.Repeat("=", 60))
}

// Helper functions

func getSeverityColor(severity string) func(a ...interface{}) string {
	switch strings.ToLower(severity) {
	case "critical":
		return colorRed
	case "high":
		return colorRed
	case "medium":
		return colorYellow
	case "low":
		return colorCyan
	default:
		return colorWhite
	}
}

func getOverallSeverity(exploits []Exploit) string {
	if len(exploits) == 0 {
		return "low"
	}

	hasCritical := false
	hasHigh := false

	for _, exploit := range exploits {
		if exploit.Severity == "critical" {
			hasCritical = true
		} else if exploit.Severity == "high" {
			hasHigh = true
		}
	}

	if hasCritical {
		return "critical"
	} else if hasHigh {
		return "high"
	}

	return "medium"
}
