package exploit

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// GenerateExploitFiles creates exploit proof-of-concept files
func GenerateExploitFiles(exploits []Exploit, outputDir string) error {
	if len(exploits) == 0 {
		return nil
	}

	// Create exploits directory
	exploitsDir := filepath.Join(outputDir, "exploits")
	if err := os.MkdirAll(exploitsDir, 0755); err != nil {
		return err
	}

	for i, exploit := range exploits {
		filename := fmt.Sprintf("%s_%s_%d",
			sanitizeFilename(exploit.Subdomain),
			sanitizeFilename(string(exploit.VulnType)),
			i+1,
		)

		switch exploit.VulnType {
		case VulnXSS:
			if err := generateXSSExploit(exploit, filepath.Join(exploitsDir, filename+".html")); err != nil {
				return err
			}
		case VulnSQLi:
			if err := generateSQLiExploit(exploit, filepath.Join(exploitsDir, filename+".py")); err != nil {
				return err
			}
		case VulnIDOR:
			if err := generateIDORExploit(exploit, filepath.Join(exploitsDir, filename+".sh")); err != nil {
				return err
			}
		case VulnPathTraversal:
			if err := generatePathTraversalExploit(exploit, filepath.Join(exploitsDir, filename+".sh")); err != nil {
				return err
			}
		case VulnSSRF:
			if err := generateSSRFExploit(exploit, filepath.Join(exploitsDir, filename+".sh")); err != nil {
				return err
			}
		case VulnOpenRedirect:
			if err := generateOpenRedirectExploit(exploit, filepath.Join(exploitsDir, filename+".html")); err != nil {
				return err
			}
		}

		// Update exploit file path
		exploits[i].ExploitFile = filepath.Join(exploitsDir, filename)
	}

	return nil
}

// generateXSSExploit creates HTML PoC for XSS
func generateXSSExploit(exploit Exploit, filePath string) error {
	content := fmt.Sprintf(`<!DOCTYPE html>
<html>
<head>
    <title>XSS PoC - %s</title>
</head>
<body>
    <h1>XSS Proof of Concept</h1>
    <p><strong>Target:</strong> %s</p>
    <p><strong>Payload:</strong> <code>%s</code></p>
    <p><strong>Method:</strong> %s</p>
    <p><strong>Evidence:</strong> %s</p>

    <h2>Exploit</h2>
    <p>Click the button below to trigger the XSS:</p>
    <button onclick="window.location='%s'">Trigger XSS</button>

    <h2>Manual Test</h2>
    <p>Or paste this URL in your browser:</p>
    <textarea rows="3" cols="80">%s</textarea>

    <h2>Impact</h2>
    <p>%s</p>

    <h2>AI Analysis</h2>
    <p>%s</p>
</body>
</html>`,
		exploit.Subdomain,
		exploit.URL,
		htmlEscape(exploit.Payload),
		exploit.Method,
		exploit.Evidence,
		exploit.URL,
		exploit.URL,
		exploit.Impact,
		exploit.AIReasoning,
	)

	return os.WriteFile(filePath, []byte(content), 0644)
}

// generateSQLiExploit creates Python script for SQLi
func generateSQLiExploit(exploit Exploit, filePath string) error {
	content := fmt.Sprintf(`#!/usr/bin/env python3
"""
SQL Injection Exploit PoC
Target: %s
Payload: %s
"""

import requests
import urllib.parse

# Target details
url = "%s"
method = "%s"
payload = "%s"

# Evidence from initial test
print("[*] SQL Injection found on: " + url)
print("[*] Payload: " + payload)
print("[*] Evidence: %s")
print("[*] Status Code: %d")
print()

# Test the exploit
print("[*] Sending request...")
if method == "GET":
    response = requests.get(url, verify=False, timeout=10)
else:
    response = requests.post(url, data={"param": payload}, verify=False, timeout=10)

print(f"[+] Status Code: {response.status_code}")
print(f"[+] Response Length: {len(response.text)} bytes")
print()
print("[+] Response Preview:")
print(response.text[:500])
print()

print("=" * 50)
print("IMPACT: %s")
print("=" * 50)
print()
print("AI Analysis: %s")
`,
		exploit.Subdomain,
		exploit.Payload,
		exploit.URL,
		exploit.Method,
		exploit.Payload,
		exploit.Evidence,
		exploit.StatusCode,
		exploit.Impact,
		exploit.AIReasoning,
	)

	return os.WriteFile(filePath, []byte(content), 0755)
}

// generateIDORExploit creates bash script for IDOR
func generateIDORExploit(exploit Exploit, filePath string) error {
	content := fmt.Sprintf(`#!/bin/bash
#
# IDOR Exploit PoC
# Target: %s
# Payload: %s
#

echo "=================================================="
echo "IDOR Vulnerability Exploit"
echo "=================================================="
echo ""
echo "Target: %s"
echo "Payload: %s"
echo "Evidence: %s"
echo ""

echo "[*] Testing IDOR vulnerability..."
echo ""

curl -s -k "%s" | head -n 20

echo ""
echo "=================================================="
echo "IMPACT: %s"
echo "=================================================="
echo ""
echo "AI Analysis: %s"
`,
		exploit.Subdomain,
		exploit.Payload,
		exploit.URL,
		exploit.Payload,
		exploit.Evidence,
		exploit.URL,
		exploit.Impact,
		exploit.AIReasoning,
	)

	return os.WriteFile(filePath, []byte(content), 0755)
}

// generatePathTraversalExploit creates bash script for path traversal
func generatePathTraversalExploit(exploit Exploit, filePath string) error {
	content := fmt.Sprintf(`#!/bin/bash
#
# Path Traversal/LFI Exploit PoC
# Target: %s
# Payload: %s
#

echo "=================================================="
echo "Path Traversal Vulnerability Exploit"
echo "=================================================="
echo ""
echo "Target: %s"
echo "Payload: %s"
echo "Evidence: %s"
echo ""

echo "[*] Attempting to read sensitive files..."
echo ""

curl -s -k "%s"

echo ""
echo "=================================================="
echo "IMPACT: %s"
echo "=================================================="
echo ""
echo "AI Analysis: %s"
`,
		exploit.Subdomain,
		exploit.Payload,
		exploit.URL,
		exploit.Payload,
		exploit.Evidence,
		exploit.URL,
		exploit.Impact,
		exploit.AIReasoning,
	)

	return os.WriteFile(filePath, []byte(content), 0755)
}

// generateSSRFExploit creates bash script for SSRF
func generateSSRFExploit(exploit Exploit, filePath string) error {
	content := fmt.Sprintf(`#!/bin/bash
#
# SSRF Exploit PoC
# Target: %s
# Payload: %s
#

echo "=================================================="
echo "SSRF Vulnerability Exploit"
echo "=================================================="
echo ""
echo "Target: %s"
echo "Payload: %s"
echo "Evidence: %s"
echo "Extracted: %s"
echo ""

echo "[*] Testing SSRF vulnerability..."
echo ""

curl -s -k "%s" | head -n 30

echo ""
echo "=================================================="
echo "IMPACT: %s"
echo "=================================================="
echo ""
echo "AI Analysis: %s"
`,
		exploit.Subdomain,
		exploit.Payload,
		exploit.URL,
		exploit.Payload,
		exploit.Evidence,
		exploit.ExtractedData,
		exploit.URL,
		exploit.Impact,
		exploit.AIReasoning,
	)

	return os.WriteFile(filePath, []byte(content), 0755)
}

// generateOpenRedirectExploit creates HTML PoC for open redirect
func generateOpenRedirectExploit(exploit Exploit, filePath string) error {
	content := fmt.Sprintf(`<!DOCTYPE html>
<html>
<head>
    <title>Open Redirect PoC - %s</title>
</head>
<body>
    <h1>Open Redirect Proof of Concept</h1>
    <p><strong>Target:</strong> %s</p>
    <p><strong>Payload:</strong> <code>%s</code></p>
    <p><strong>Evidence:</strong> %s</p>

    <h2>Exploit</h2>
    <p>Click the button below to trigger the redirect:</p>
    <button onclick="window.location='%s'">Trigger Redirect</button>

    <h2>Manual Test</h2>
    <p>Or paste this URL in your browser:</p>
    <textarea rows="3" cols="80">%s</textarea>

    <h2>Phishing Scenario</h2>
    <p>This vulnerability can be exploited for phishing:</p>
    <pre>
    Attacker sends: %s
    User trusts the legitimate domain (%s)
    But gets redirected to malicious site
    </pre>

    <h2>Impact</h2>
    <p>%s</p>

    <h2>AI Analysis</h2>
    <p>%s</p>
</body>
</html>`,
		exploit.Subdomain,
		exploit.URL,
		htmlEscape(exploit.Payload),
		exploit.Evidence,
		exploit.URL,
		exploit.URL,
		exploit.URL,
		exploit.Subdomain,
		exploit.Impact,
		exploit.AIReasoning,
	)

	return os.WriteFile(filePath, []byte(content), 0644)
}

// sanitizeFilename removes invalid characters from filename
func sanitizeFilename(name string) string {
	// Replace invalid characters
	replacer := strings.NewReplacer(
		"/", "_",
		"\\", "_",
		":", "_",
		"*", "_",
		"?", "_",
		"\"", "_",
		"<", "_",
		">", "_",
		"|", "_",
		" ", "_",
		".", "_",
	)

	return replacer.Replace(name)
}

// htmlEscape escapes HTML special characters
func htmlEscape(s string) string {
	s = strings.ReplaceAll(s, "&", "&amp;")
	s = strings.ReplaceAll(s, "<", "&lt;")
	s = strings.ReplaceAll(s, ">", "&gt;")
	s = strings.ReplaceAll(s, "\"", "&quot;")
	s = strings.ReplaceAll(s, "'", "&#39;")
	return s
}
