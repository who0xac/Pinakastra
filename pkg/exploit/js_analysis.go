package exploit

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"regexp"
	"strings"
)

// analyzeJavaScript performs deep JavaScript analysis
func (s *Scanner) analyzeJavaScript(ctx context.Context, subdomain string, urls []string) *JSAnalysisResult {
	result := &JSAnalysisResult{
		Subdomain:         subdomain,
		JSFiles:           make([]string, 0),
		Secrets:           make([]JSSecret, 0),
		APIEndpoints:      make([]JSEndpoint, 0),
		HiddenParams:      make([]string, 0),
		AuthLogicFlaws:    make([]string, 0),
		SensitiveComments: make([]string, 0),
	}

	// Find JS files from URLs
	jsFiles := s.findJSFiles(urls)
	if len(jsFiles) == 0 {
		return nil // No JS files found
	}

	result.JSFiles = jsFiles

	// Analyze each JS file
	for _, jsFile := range jsFiles {
		content := s.fetchJSFile(ctx, jsFile)
		if content == "" {
			continue
		}

		// Extract secrets
		secrets := s.extractSecrets(jsFile, content)
		result.Secrets = append(result.Secrets, secrets...)

		// Extract API endpoints
		endpoints := s.extractAPIEndpoints(jsFile, content)
		result.APIEndpoints = append(result.APIEndpoints, endpoints...)

		// Extract hidden parameters
		params := s.extractHiddenParams(content)
		result.HiddenParams = append(result.HiddenParams, params...)

		// Find auth logic flaws
		authFlaws := s.findAuthFlaws(content)
		result.AuthLogicFlaws = append(result.AuthLogicFlaws, authFlaws...)

		// Extract sensitive comments
		comments := s.extractSensitiveComments(content)
		result.SensitiveComments = append(result.SensitiveComments, comments...)
	}

	// If nothing found, return nil
	if len(result.Secrets) == 0 && len(result.APIEndpoints) == 0 &&
		len(result.HiddenParams) == 0 && len(result.AuthLogicFlaws) == 0 &&
		len(result.SensitiveComments) == 0 {
		return nil
	}

	return result
}

// findJSFiles filters JS files from URL list
func (s *Scanner) findJSFiles(urls []string) []string {
	var jsFiles []string
	for _, url := range urls {
		if strings.HasSuffix(url, ".js") {
			jsFiles = append(jsFiles, url)
		}
	}
	return jsFiles
}

// fetchJSFile downloads JS file content
func (s *Scanner) fetchJSFile(ctx context.Context, url string) string {
	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return ""
	}

	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")

	resp, err := s.client.Do(req)
	if err != nil {
		return ""
	}
	defer resp.Body.Close()

	// Limit to 5MB
	body, err := io.ReadAll(io.LimitReader(resp.Body, 5*1024*1024))
	if err != nil {
		return ""
	}

	return string(body)
}

// extractSecrets finds API keys, tokens, credentials in JS
func (s *Scanner) extractSecrets(file, content string) []JSSecret {
	var secrets []JSSecret

	patterns := map[string]*regexp.Regexp{
		"AWS Access Key":     regexp.MustCompile(`(AKIA[0-9A-Z]{16})`),
		"AWS Secret Key":     regexp.MustCompile(`([0-9a-zA-Z/+]{40})`),
		"Google API Key":     regexp.MustCompile(`AIza[0-9A-Za-z\\-_]{35}`),
		"GitHub Token":       regexp.MustCompile(`gh[pousr]_[0-9a-zA-Z]{36}`),
		"JWT Token":          regexp.MustCompile(`eyJ[A-Za-z0-9-_=]+\.eyJ[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*`),
		"Private Key":        regexp.MustCompile(`-----BEGIN (RSA |EC |OPENSSH )?PRIVATE KEY-----`),
		"Slack Token":        regexp.MustCompile(`xox[baprs]-[0-9a-zA-Z]{10,48}`),
		"Stripe Key":         regexp.MustCompile(`(sk|pk)_(test|live)_[0-9a-zA-Z]{24,}`),
		"Mailgun API Key":    regexp.MustCompile(`key-[0-9a-zA-Z]{32}`),
		"Twilio API Key":     regexp.MustCompile(`SK[0-9a-fA-F]{32}`),
		"SendGrid API Key":   regexp.MustCompile(`SG\.[0-9A-Za-z\-_]{22}\.[0-9A-Za-z\-_]{43}`),
		"Password/Secret":    regexp.MustCompile(`(?i)(password|secret|token|apikey)\s*[:=]\s*["']([^"']{8,})["']`),
	}

	lines := strings.Split(content, "\n")

	for secretType, pattern := range patterns {
		matches := pattern.FindAllStringSubmatch(content, -1)
		for _, match := range matches {
			if len(match) > 0 {
				value := match[0]
				if len(match) > 1 {
					value = match[1]
				}

				// Find line number
				lineNum := s.findLineNumber(lines, value)

				// Get context (surrounding code)
				context := s.getContext(lines, lineNum, 2)

				secrets = append(secrets, JSSecret{
					File:       file,
					SecretType: secretType,
					Value:      value,
					LineNumber: lineNum,
					Context:    context,
				})
			}
		}
	}

	return secrets
}

// extractAPIEndpoints finds API endpoints in JS
func (s *Scanner) extractAPIEndpoints(file, content string) []JSEndpoint {
	var endpoints []JSEndpoint

	// Patterns for API endpoints
	patterns := []*regexp.Regexp{
		regexp.MustCompile(`["'](/api/[a-zA-Z0-9/_-]+)["']`),
		regexp.MustCompile(`["'](/v[0-9]+/[a-zA-Z0-9/_-]+)["']`),
		regexp.MustCompile(`["'](/graphql[a-zA-Z0-9/_-]*)["']`),
		regexp.MustCompile(`fetch\(["']([^"']+)["']`),
		regexp.MustCompile(`axios\.(get|post|put|delete)\(["']([^"']+)["']`),
		regexp.MustCompile(`\$\.ajax\(\{[^}]*url:\s*["']([^"']+)["']`),
	}

	lines := strings.Split(content, "\n")

	for _, pattern := range patterns {
		matches := pattern.FindAllStringSubmatch(content, -1)
		for _, match := range matches {
			if len(match) >= 2 {
				endpoint := match[1]
				method := "GET"

				// Try to determine HTTP method
				if len(match) > 2 {
					method = strings.ToUpper(match[1])
					endpoint = match[2]
				}

				lineNum := s.findLineNumber(lines, endpoint)
				context := s.getContext(lines, lineNum, 1)

				endpoints = append(endpoints, JSEndpoint{
					File:       file,
					Endpoint:   endpoint,
					Method:     method,
					LineNumber: lineNum,
					Context:    context,
				})
			}
		}
	}

	return endpoints
}

// extractHiddenParams finds hidden parameters in JS
func (s *Scanner) extractHiddenParams(content string) []string {
	var params []string
	seen := make(map[string]bool)

	// Patterns for parameters
	patterns := []*regexp.Regexp{
		regexp.MustCompile(`["']([a-zA-Z_][a-zA-Z0-9_]*)["']\s*:\s*`),                    // Object keys
		regexp.MustCompile(`\?([a-zA-Z_][a-zA-Z0-9_]*)=`),                                 // Query params
		regexp.MustCompile(`data\[["']([a-zA-Z_][a-zA-Z0-9_]*)["']\]`),                   // Array access
		regexp.MustCompile(`\.setAttribute\(["']([a-zA-Z_][a-zA-Z0-9_-]*)["']`),          // HTML attributes
	}

	for _, pattern := range patterns {
		matches := pattern.FindAllStringSubmatch(content, -1)
		for _, match := range matches {
			if len(match) >= 2 {
				param := match[1]
				// Filter common/boring params
				if s.isInterestingParam(param) && !seen[param] {
					params = append(params, param)
					seen[param] = true
				}
			}
		}
	}

	return params
}

// findAuthFlaws detects authentication logic flaws
func (s *Scanner) findAuthFlaws(content string) []string {
	var flaws []string

	// Patterns indicating auth flaws
	flawPatterns := map[string]*regexp.Regexp{
		"Client-side admin check":       regexp.MustCompile(`(?i)if\s*\(\s*(isAdmin|is_admin|userRole|role)\s*==\s*["']admin["']`),
		"Hardcoded credentials":         regexp.MustCompile(`(?i)(username|user|email)\s*[:=]\s*["'][^"']+["'].*password\s*[:=]\s*["'][^"']+["']`),
		"JWT validation disabled":       regexp.MustCompile(`(?i)verify\s*:\s*false`),
		"Role check in frontend":        regexp.MustCompile(`(?i)if\s*\(\s*user\.(role|permission|access)`),
		"Debug mode enabled":            regexp.MustCompile(`(?i)(debug|DEBUG)\s*[:=]\s*true`),
		"Token stored in localStorage":  regexp.MustCompile(`localStorage\.(setItem|getItem)\(["'](token|jwt|auth)`),
		"CORS misconfigured":            regexp.MustCompile(`(?i)Access-Control-Allow-Origin.*\*`),
	}

	for flawName, pattern := range flawPatterns {
		if pattern.MatchString(content) {
			flaws = append(flaws, flawName)
		}
	}

	return flaws
}

// extractSensitiveComments finds sensitive information in comments
func (s *Scanner) extractSensitiveComments(content string) []string {
	var comments []string

	// Extract all comments
	commentPatterns := []*regexp.Regexp{
		regexp.MustCompile(`//\s*(.+?)$`),
		regexp.MustCompile(`/\*\s*(.+?)\s*\*/`),
	}

	sensitiveKeywords := []string{
		"todo", "fixme", "hack", "xxx", "bug", "debug",
		"password", "secret", "api", "key", "token",
		"admin", "root", "bypass", "vulnerability",
	}

	for _, pattern := range commentPatterns {
		matches := pattern.FindAllStringSubmatch(content, -1)
		for _, match := range matches {
			if len(match) >= 2 {
				comment := strings.ToLower(match[1])
				for _, keyword := range sensitiveKeywords {
					if strings.Contains(comment, keyword) {
						comments = append(comments, match[1])
						break
					}
				}
			}
		}
	}

	return comments
}

// isInterestingParam filters boring parameter names
func (s *Scanner) isInterestingParam(param string) bool {
	boring := []string{
		"id", "name", "type", "value", "data", "key", "item",
		"index", "length", "size", "count", "total", "page",
		"true", "false", "null", "undefined",
	}

	param = strings.ToLower(param)
	for _, b := range boring {
		if param == b {
			return false
		}
	}

	return len(param) > 2 && len(param) < 50
}

// findLineNumber finds line number of text
func (s *Scanner) findLineNumber(lines []string, text string) int {
	for i, line := range lines {
		if strings.Contains(line, text) {
			return i + 1
		}
	}
	return 0
}

// getContext returns surrounding lines for context
func (s *Scanner) getContext(lines []string, lineNum, contextLines int) string {
	if lineNum == 0 {
		return ""
	}

	start := lineNum - 1 - contextLines
	if start < 0 {
		start = 0
	}

	end := lineNum + contextLines
	if end > len(lines) {
		end = len(lines)
	}

	context := make([]string, 0)
	for i := start; i < end; i++ {
		prefix := "  "
		if i == lineNum-1 {
			prefix = "â†’ "
		}
		context = append(context, fmt.Sprintf("%s%s", prefix, lines[i]))
	}

	return strings.Join(context, "\n")
}
