package exploit

import (
	"context"
	"crypto/tls"
	"net/http"
	"time"
)

// VulnerabilityType represents different vulnerability types
type VulnerabilityType string

const (
	VulnXSS            VulnerabilityType = "XSS"
	VulnSQLi           VulnerabilityType = "SQL Injection"
	VulnIDOR           VulnerabilityType = "IDOR"
	VulnPathTraversal  VulnerabilityType = "Path Traversal/LFI"
	VulnSSRF           VulnerabilityType = "SSRF"
	VulnOpenRedirect   VulnerabilityType = "Open Redirect"
	VulnJWT            VulnerabilityType = "JWT Manipulation"
	VulnJSAnalysis     VulnerabilityType = "Deep JS Analysis"
)

// Exploit represents a working exploit
type Exploit struct {
	Subdomain     string            `json:"subdomain"`
	URL           string            `json:"url"`
	VulnType      VulnerabilityType `json:"vulnerability_type"`
	Severity      string            `json:"severity"` // critical, high, medium, low
	Payload       string            `json:"payload"`
	Method        string            `json:"method"` // GET, POST, etc.
	StatusCode    int               `json:"status_code"`
	Response      string            `json:"response"` // Snippet showing it worked
	Evidence      string            `json:"evidence"`
	Impact        string            `json:"impact"`
	BypassUsed    string            `json:"bypass_used,omitempty"`    // WAF bypass technique
	AIReasoning   string            `json:"ai_reasoning,omitempty"`   // AI's thought process
	ExtractedData string            `json:"extracted_data,omitempty"` // DB version, secrets, etc.
	ExploitFile   string            `json:"exploit_file,omitempty"`   // Path to generated exploit
	Verified      bool              `json:"verified"`
}

// JSSecret represents secrets found in JavaScript files
type JSSecret struct {
	File       string `json:"file"`
	SecretType string `json:"secret_type"` // API key, AWS key, JWT, etc.
	Value      string `json:"value"`
	LineNumber int    `json:"line_number"`
	Context    string `json:"context"` // Surrounding code
}

// JSEndpoint represents API endpoints found in JS
type JSEndpoint struct {
	File       string `json:"file"`
	Endpoint   string `json:"endpoint"`
	Method     string `json:"method"`
	LineNumber int    `json:"line_number"`
	Context    string `json:"context"`
}

// JSAnalysisResult represents Deep JS Analysis results
type JSAnalysisResult struct {
	Subdomain       string       `json:"subdomain"`
	JSFiles         []string     `json:"js_files"`
	Secrets         []JSSecret   `json:"secrets"`
	APIEndpoints    []JSEndpoint `json:"api_endpoints"`
	HiddenParams    []string     `json:"hidden_params"`
	AuthLogicFlaws  []string     `json:"auth_logic_flaws"`
	SensitiveComments []string   `json:"sensitive_comments"`
}

// ExploitAttempt represents a single exploitation attempt
type ExploitAttempt struct {
	VulnType   VulnerabilityType `json:"vulnerability_type"`
	Payload    string            `json:"payload"`
	URL        string            `json:"url"`
	Method     string            `json:"method"`
	StatusCode int               `json:"status_code"`
	Success    bool              `json:"success"`
	Response   string            `json:"response"` // First 500 chars
	AINote     string            `json:"ai_note"`  // "WAF detected, trying bypass..."
}

// SubdomainResult represents all results for a subdomain
type SubdomainResult struct {
	Subdomain     string             `json:"subdomain"`
	StatusCode    int                `json:"status_code"`
	JSAnalysis    *JSAnalysisResult  `json:"js_analysis,omitempty"`
	Attempts      []ExploitAttempt   `json:"attempts"`
	Exploits      []Exploit          `json:"exploits"`
	TotalAttempts int                `json:"total_attempts"`
	TotalExploits int                `json:"total_exploits"`
}

// Scanner performs active exploitation
type Scanner struct {
	client      *http.Client
	timeout     time.Duration
	aiModel     string
	ollamaURL   string
	maxRetries  int
	concurrency int
}

// NewScanner creates a new exploit scanner
func NewScanner(timeout int, aiModel, ollamaURL string) *Scanner {
	return &Scanner{
		client: &http.Client{
			Timeout: time.Duration(timeout) * time.Second,
			Transport: &http.Transport{
				TLSClientConfig: &tls.Config{
					InsecureSkipVerify: true,
				},
				// Optimized for parallel testing (8 vulnerability types at once)
				MaxIdleConns:        200,  // Increased from 100 for parallel tests
				MaxIdleConnsPerHost: 50,   // Increased from 20 for parallel tests
				MaxConnsPerHost:     100,  // Limit concurrent connections per host
				IdleConnTimeout:     90 * time.Second,
				DisableKeepAlives:   false, // Keep connections alive for reuse
				DisableCompression:  false, // Allow compression
			},
			CheckRedirect: func(req *http.Request, via []*http.Request) error {
				// Follow up to 5 redirects
				if len(via) >= 5 {
					return http.ErrUseLastResponse
				}
				return nil
			},
		},
		timeout:     time.Duration(timeout) * time.Second,
		aiModel:     aiModel,
		ollamaURL:   ollamaURL,
		maxRetries:  3,
		concurrency: 1, // Process one subdomain at a time
	}
}

// ScanSubdomainWithProgress performs all exploitation tests with live progress updates
// Now uses consolidated vulnerability_tests.go with adaptive AI payloads
func (s *Scanner) ScanSubdomainWithProgress(ctx context.Context, subdomain string, urls []string, progressChan chan<- string) (*SubdomainResult, error) {
	// Use the new consolidated vulnerability testing system
	return s.TestAllVulnerabilities(ctx, subdomain, urls, progressChan)
}

// ScanSubdomain performs all exploitation tests on a single subdomain
func (s *Scanner) ScanSubdomain(ctx context.Context, subdomain string, urls []string) (*SubdomainResult, error) {
	return s.ScanSubdomainWithProgress(ctx, subdomain, urls, nil)
}

// Helper function to get status code
func (s *Scanner) getStatusCode(ctx context.Context, subdomain string) int {
	urls := []string{
		"https://" + subdomain,
		"http://" + subdomain,
	}

	for _, url := range urls {
		req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
		if err != nil {
			continue
		}
		req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")

		resp, err := s.client.Do(req)
		if err != nil {
			continue
		}
		resp.Body.Close()
		return resp.StatusCode
	}

	return 0
}
