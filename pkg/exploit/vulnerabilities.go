package exploit

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// testSQLi performs SQL injection exploitation testing
func (s *Scanner) testSQLi(ctx context.Context, subdomain string, urls []string) []Exploit {
	var exploits []Exploit

	for _, targetURL := range urls {
		parsedURL, err := url.Parse(targetURL)
		if err != nil || parsedURL.RawQuery == "" {
			continue
		}

		params := parsedURL.Query()
		for param := range params {
			exploit := s.testSQLiParameter(ctx, subdomain, targetURL, param)
			if exploit != nil {
				exploits = append(exploits, *exploit)
			}
		}
	}

	return exploits
}

func (s *Scanner) testSQLiParameter(ctx context.Context, subdomain, targetURL, param string) *Exploit {
	payloads, aiReasoning := s.generateSQLiPayloads(ctx, targetURL, param)

	for _, payload := range payloads {
		testURL := s.buildTestURL(targetURL, param, payload)

		req, err := http.NewRequestWithContext(ctx, "GET", testURL, nil)
		if err != nil {
			continue
		}
		req.Header.Set("User-Agent", "Mozilla/5.0")

		resp, err := s.client.Do(req)
		if err != nil {
			continue
		}

		body, _ := io.ReadAll(io.LimitReader(resp.Body, 100*1024))
		resp.Body.Close()

		bodyStr := string(body)

		success, evidence, reasoning := s.analyzeResponse(ctx, string(VulnSQLi), payload, bodyStr, resp.StatusCode)

		if success {
			return &Exploit{
				Subdomain:     subdomain,
				URL:           testURL,
				VulnType:      VulnSQLi,
				Severity:      "critical",
				Payload:       payload,
				Method:        "GET",
				StatusCode:    resp.StatusCode,
				Response:      truncate(bodyStr, 500),
				Evidence:      evidence,
				Impact:        "SQL Injection allows attacker to read/modify database, bypass authentication",
				AIReasoning:   reasoning + " | " + aiReasoning,
				ExtractedData: s.extractSQLiData(bodyStr),
				Verified:      true,
			}
		}
	}

	return nil
}

func (s *Scanner) extractSQLiData(response string) string {
	// Extract database version, table names, etc.
	if strings.Contains(strings.ToLower(response), "mysql") {
		return "MySQL database detected"
	} else if strings.Contains(strings.ToLower(response), "postgresql") {
		return "PostgreSQL database detected"
	} else if strings.Contains(strings.ToLower(response), "mssql") || strings.Contains(strings.ToLower(response), "microsoft sql") {
		return "Microsoft SQL Server detected"
	}
	return "Database error detected"
}

// testIDOR performs IDOR exploitation testing
func (s *Scanner) testIDOR(ctx context.Context, subdomain string, urls []string) []Exploit {
	var exploits []Exploit

	// Look for URLs with ID parameters
	for _, targetURL := range urls {
		if exploit := s.testIDORURL(ctx, subdomain, targetURL); exploit != nil {
			exploits = append(exploits, *exploit)
		}
	}

	return exploits
}

func (s *Scanner) testIDORURL(ctx context.Context, subdomain, targetURL string) *Exploit {
	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		return nil
	}

	params := parsedURL.Query()

	// Look for ID-like parameters
	idParams := []string{"id", "user_id", "uid", "userid", "account", "user", "profile"}

	for _, param := range idParams {
		if originalID := params.Get(param); originalID != "" {
			// Try different IDs
			testIDs := []string{"1", "2", "100", "999", originalID + "1"}

			for _, testID := range testIDs {
				params.Set(param, testID)
				parsedURL.RawQuery = params.Encode()
				testURL := parsedURL.String()

				req, err := http.NewRequestWithContext(ctx, "GET", testURL, nil)
				if err != nil {
					continue
				}
				req.Header.Set("User-Agent", "Mozilla/5.0")

				resp, err := s.client.Do(req)
				if err != nil {
					continue
				}

				body, _ := io.ReadAll(io.LimitReader(resp.Body, 100*1024))
				resp.Body.Close()

				bodyStr := string(body)

				// Check if we got different user data
				if resp.StatusCode == 200 && len(bodyStr) > 100 {
					// AI analyzes if this is actual IDOR
					success, evidence, reasoning := s.analyzeResponse(ctx, string(VulnIDOR), testID, bodyStr, resp.StatusCode)

					if success {
						return &Exploit{
							Subdomain:     subdomain,
							URL:           testURL,
							VulnType:      VulnIDOR,
							Severity:      "high",
							Payload:       fmt.Sprintf("%s=%s", param, testID),
							Method:        "GET",
							StatusCode:    resp.StatusCode,
							Response:      truncate(bodyStr, 500),
							Evidence:      evidence,
							Impact:        "IDOR allows unauthorized access to other users' data",
							AIReasoning:   reasoning,
							ExtractedData: "Accessed user ID: " + testID,
							Verified:      true,
						}
					}
				}
			}
		}
	}

	return nil
}

// testPathTraversal performs path traversal/LFI testing
func (s *Scanner) testPathTraversal(ctx context.Context, subdomain string, urls []string) []Exploit {
	var exploits []Exploit

	for _, targetURL := range urls {
		if exploit := s.testPathTraversalURL(ctx, subdomain, targetURL); exploit != nil {
			exploits = append(exploits, *exploit)
		}
	}

	return exploits
}

func (s *Scanner) testPathTraversalURL(ctx context.Context, subdomain, targetURL string) *Exploit {
	payloads, aiReasoning := s.generatePathTraversalPayloads(ctx, targetURL)

	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		return nil
	}

	params := parsedURL.Query()

	// Test file-related parameters
	fileParams := []string{"file", "path", "page", "include", "template", "document"}

	for _, param := range fileParams {
		for _, payload := range payloads {
			params.Set(param, payload)
			parsedURL.RawQuery = params.Encode()
			testURL := parsedURL.String()

			req, err := http.NewRequestWithContext(ctx, "GET", testURL, nil)
			if err != nil {
				continue
			}
			req.Header.Set("User-Agent", "Mozilla/5.0")

			resp, err := s.client.Do(req)
			if err != nil {
				continue
			}

			body, _ := io.ReadAll(io.LimitReader(resp.Body, 100*1024))
			resp.Body.Close()

			bodyStr := string(body)

			success, evidence, reasoning := s.analyzeResponse(ctx, string(VulnPathTraversal), payload, bodyStr, resp.StatusCode)

			if success {
				return &Exploit{
					Subdomain:     subdomain,
					URL:           testURL,
					VulnType:      VulnPathTraversal,
					Severity:      "high",
					Payload:       payload,
					Method:        "GET",
					StatusCode:    resp.StatusCode,
					Response:      truncate(bodyStr, 500),
					Evidence:      evidence,
					Impact:        "Path Traversal allows reading sensitive files from server",
					AIReasoning:   reasoning + " | " + aiReasoning,
					ExtractedData: "File contents leaked",
					Verified:      true,
				}
			}
		}
	}

	return nil
}

// testSSRF performs SSRF exploitation testing
func (s *Scanner) testSSRF(ctx context.Context, subdomain string, urls []string) []Exploit {
	var exploits []Exploit

	for _, targetURL := range urls {
		if exploit := s.testSSRFURL(ctx, subdomain, targetURL); exploit != nil {
			exploits = append(exploits, *exploit)
		}
	}

	return exploits
}

func (s *Scanner) testSSRFURL(ctx context.Context, subdomain, targetURL string) *Exploit {
	payloads, aiReasoning := s.generateSSRFPayloads(ctx, targetURL)

	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		return nil
	}

	params := parsedURL.Query()

	// Test URL-related parameters
	urlParams := []string{"url", "uri", "link", "redirect", "fetch", "proxy", "webhook"}

	for _, param := range urlParams {
		for _, payload := range payloads {
			params.Set(param, payload)
			parsedURL.RawQuery = params.Encode()
			testURL := parsedURL.String()

			req, err := http.NewRequestWithContext(ctx, "GET", testURL, nil)
			if err != nil {
				continue
			}
			req.Header.Set("User-Agent", "Mozilla/5.0")

			resp, err := s.client.Do(req)
			if err != nil {
				continue
			}

			body, _ := io.ReadAll(io.LimitReader(resp.Body, 100*1024))
			resp.Body.Close()

			bodyStr := string(body)

			success, evidence, reasoning := s.analyzeResponse(ctx, string(VulnSSRF), payload, bodyStr, resp.StatusCode)

			if success {
				return &Exploit{
					Subdomain:     subdomain,
					URL:           testURL,
					VulnType:      VulnSSRF,
					Severity:      "critical",
					Payload:       payload,
					Method:        "GET",
					StatusCode:    resp.StatusCode,
					Response:      truncate(bodyStr, 500),
					Evidence:      evidence,
					Impact:        "SSRF allows accessing internal services and cloud metadata",
					AIReasoning:   reasoning + " | " + aiReasoning,
					ExtractedData: s.extractSSRFData(bodyStr),
					Verified:      true,
				}
			}
		}
	}

	return nil
}

func (s *Scanner) extractSSRFData(response string) string {
	if strings.Contains(response, "169.254.169.254") {
		return "AWS metadata endpoint accessible"
	} else if strings.Contains(response, "metadata.google.internal") {
		return "GCP metadata endpoint accessible"
	} else if strings.Contains(response, "127.0.0.1") || strings.Contains(response, "localhost") {
		return "Internal service accessible"
	}
	return "SSRF successful"
}

// testOpenRedirect performs open redirect testing
func (s *Scanner) testOpenRedirect(ctx context.Context, subdomain string, urls []string) []Exploit {
	var exploits []Exploit

	for _, targetURL := range urls {
		if exploit := s.testOpenRedirectURL(ctx, subdomain, targetURL); exploit != nil {
			exploits = append(exploits, *exploit)
		}
	}

	return exploits
}

func (s *Scanner) testOpenRedirectURL(ctx context.Context, subdomain, targetURL string) *Exploit {
	payloads, aiReasoning := s.generateOpenRedirectPayloads(ctx, targetURL)

	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		return nil
	}

	params := parsedURL.Query()

	// Test redirect parameters
	redirectParams := []string{"redirect", "url", "next", "return", "goto", "destination", "redir", "out"}

	for _, param := range redirectParams {
		for _, payload := range payloads {
			params.Set(param, payload)
			parsedURL.RawQuery = params.Encode()
			testURL := parsedURL.String()

			req, err := http.NewRequestWithContext(ctx, "GET", testURL, nil)
			if err != nil {
				continue
			}
			req.Header.Set("User-Agent", "Mozilla/5.0")

			// Don't follow redirects automatically
			client := &http.Client{
				CheckRedirect: func(req *http.Request, via []*http.Request) error {
					return http.ErrUseLastResponse
				},
				Timeout: s.timeout,
			}

			resp, err := client.Do(req)
			if err != nil {
				continue
			}

			location := resp.Header.Get("Location")
			resp.Body.Close()

			// Check if redirected to external domain
			if resp.StatusCode >= 300 && resp.StatusCode < 400 {
				if strings.Contains(location, "evil.com") || strings.HasPrefix(location, "//") {
					return &Exploit{
						Subdomain:     subdomain,
						URL:           testURL,
						VulnType:      VulnOpenRedirect,
						Severity:      "medium",
						Payload:       payload,
						Method:        "GET",
						StatusCode:    resp.StatusCode,
						Response:      "Location: " + location,
						Evidence:      "Redirects to: " + location,
						Impact:        "Open Redirect can be used for phishing attacks",
						AIReasoning:   aiReasoning,
						ExtractedData: "Redirect location: " + location,
						Verified:      true,
					}
				}
			}
		}
	}

	return nil
}

// testJWT performs JWT manipulation testing
func (s *Scanner) testJWT(ctx context.Context, subdomain string, urls []string) []Exploit {
	var exploits []Exploit

	// This would involve:
	// 1. Finding JWT tokens in responses/cookies
	// 2. Testing algorithm confusion (RS256 -> HS256)
	// 3. Testing none algorithm
	// 4. Testing weak secrets
	// 5. Testing expired tokens

	// For now, return empty (stub implementation)
	// A full JWT exploit would require:
	// - Cookie jar to capture tokens
	// - JWT parsing library
	// - Token manipulation logic

	return exploits
}
