package exploit

import (
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"sync"
)

// TestAllVulnerabilities runs all vulnerability tests with adaptive AI payloads in parallel
func (s *Scanner) TestAllVulnerabilities(ctx context.Context, subdomain string, urls []string, progressChan chan<- string) (*SubdomainResult, error) {
	result := &SubdomainResult{
		Subdomain: subdomain,
		Attempts:  make([]ExploitAttempt, 0),
		Exploits:  make([]Exploit, 0),
	}

	// Get status code
	result.StatusCode = s.getStatusCode(ctx, subdomain)

	// Send start message for all tests (8 payloads: 5 hardcoded + 3 AI)
	sendProgressUpdate(progressChan, "start", "XSS", "", 0,10)
	sendProgressUpdate(progressChan, "start", "SQLi", "", 0,10)
	sendProgressUpdate(progressChan, "start", "IDOR", "", 0,10)
	sendProgressUpdate(progressChan, "start", "Path Traversal", "", 0,10)
	sendProgressUpdate(progressChan, "start", "SSRF", "", 0,10)
	sendProgressUpdate(progressChan, "start", "Open Redirect", "", 0,10)
	sendProgressUpdate(progressChan, "start", "JWT", "", 0,10)
	sendProgressUpdate(progressChan, "start", "JavaScript Analysis", "", 0,10)

	// Check if we should skip JS Analysis (if no .js files in URLs)
	hasJSFiles := false
	for _, u := range urls {
		if strings.HasSuffix(u, ".js") {
			hasJSFiles = true
			break
		}
	}

	// Run all tests in parallel with goroutines
	var wg sync.WaitGroup
	var mu sync.Mutex // Protect shared result.Exploits slice

	// Test XSS
	wg.Add(1)
	go func() {
		defer wg.Done()
		xssExploits := s.testXSSVuln(ctx, subdomain, urls, progressChan)
		mu.Lock()
		result.Exploits = append(result.Exploits, xssExploits...)
		mu.Unlock()
	}()

	// Test SQLi
	wg.Add(1)
	go func() {
		defer wg.Done()
		sqliExploits := s.testSQLiVuln(ctx, subdomain, urls, progressChan)
		mu.Lock()
		result.Exploits = append(result.Exploits, sqliExploits...)
		mu.Unlock()
	}()

	// Test IDOR
	wg.Add(1)
	go func() {
		defer wg.Done()
		idorExploits := s.testIDORVuln(ctx, subdomain, urls, progressChan)
		mu.Lock()
		result.Exploits = append(result.Exploits, idorExploits...)
		mu.Unlock()
	}()

	// Test Path Traversal
	wg.Add(1)
	go func() {
		defer wg.Done()
		pathExploits := s.testPathTraversalVuln(ctx, subdomain, urls, progressChan)
		mu.Lock()
		result.Exploits = append(result.Exploits, pathExploits...)
		mu.Unlock()
	}()

	// Test SSRF
	wg.Add(1)
	go func() {
		defer wg.Done()
		ssrfExploits := s.testSSRFVuln(ctx, subdomain, urls, progressChan)
		mu.Lock()
		result.Exploits = append(result.Exploits, ssrfExploits...)
		mu.Unlock()
	}()

	// Test Open Redirect
	wg.Add(1)
	go func() {
		defer wg.Done()
		redirectExploits := s.testOpenRedirectVuln(ctx, subdomain, urls, progressChan)
		mu.Lock()
		result.Exploits = append(result.Exploits, redirectExploits...)
		mu.Unlock()
	}()

	// Test JWT
	wg.Add(1)
	go func() {
		defer wg.Done()
		jwtExploits := s.testJWTVuln(ctx, subdomain, urls, progressChan)
		mu.Lock()
		result.Exploits = append(result.Exploits, jwtExploits...)
		mu.Unlock()
	}()

	// Test JS Analysis only if .js files found
	if hasJSFiles {
		wg.Add(1)
		go func() {
			defer wg.Done()
			s.testJSAnalysisVuln(ctx, subdomain, urls, progressChan)
		}()
	} else {
		// Skip JS Analysis and mark as complete
		sendProgressUpdate(progressChan, "complete", "JavaScript Analysis", "", 0, 0)
	}

	// Wait for all tests to complete
	wg.Wait()

	result.TotalExploits = len(result.Exploits)
	return result, nil
}

// testXSSVuln tests for XSS with adaptive AI payloads (optimized with parallel hardcoded + adaptive AI)
func (s *Scanner) testXSSVuln(ctx context.Context, subdomain string, urls []string, progressChan chan<- string) []Exploit {
	var exploits []Exploit

	for _, targetURL := range urls {
		// Skip non-relevant URLs (CSS, images, fonts, etc.)
		if isStaticAsset(targetURL) {
			continue
		}

		parsedURL, err := url.Parse(targetURL)
		if err != nil || parsedURL.RawQuery == "" {
			continue
		}

		params := parsedURL.Query()
		if len(params) == 0 {
			continue
		}

		// Test each parameter with optimized flow
		for param := range params {
			exploit, found := s.testPayloadWithAdaptiveAI(
				ctx,
				subdomain,
				targetURL,
				param,
				VulnXSS,
				"Attacker can execute JavaScript in victim's browser, steal cookies, perform actions as user",
				progressChan,
			)

			if found {
				exploits = append(exploits, exploit)
				break // Early stop - found exploit for this URL
			}
		}
	}

	sendProgressUpdate(progressChan, "complete", "XSS", "", 10, 10)
	return exploits
}

// testSQLiVuln tests for SQL Injection with adaptive AI payloads (optimized with parallel hardcoded + adaptive AI)
func (s *Scanner) testSQLiVuln(ctx context.Context, subdomain string, urls []string, progressChan chan<- string) []Exploit {
	var exploits []Exploit

	for _, targetURL := range urls {
		// Skip non-relevant URLs
		if isStaticAsset(targetURL) {
			continue
		}

		parsedURL, err := url.Parse(targetURL)
		if err != nil || parsedURL.RawQuery == "" {
			continue
		}

		params := parsedURL.Query()
		if len(params) == 0 {
			continue
		}

		// Test each parameter with optimized flow
		for param := range params {
			exploit, found := s.testPayloadWithAdaptiveAI(
				ctx,
				subdomain,
				targetURL,
				param,
				VulnSQLi,
				"Attacker can read, modify, or delete database contents",
				progressChan,
			)

			if found {
				exploits = append(exploits, exploit)
				break // Early stop - found exploit for this URL
			}
		}
	}

	sendProgressUpdate(progressChan, "complete", "SQLi", "", 10, 10)
	return exploits
}

// testIDORVuln tests for IDOR with adaptive AI payloads (optimized with parallel hardcoded + adaptive AI)
func (s *Scanner) testIDORVuln(ctx context.Context, subdomain string, urls []string, progressChan chan<- string) []Exploit {
	var exploits []Exploit

	for _, targetURL := range urls {
		// Skip static assets
		if isStaticAsset(targetURL) {
			continue
		}

		// Look for ID patterns in URL (IDOR-relevant endpoints)
		if !strings.Contains(targetURL, "/users/") &&
		   !strings.Contains(targetURL, "/api/") &&
		   !strings.Contains(targetURL, "/user/") &&
		   !strings.Contains(targetURL, "/account/") &&
		   !strings.Contains(targetURL, "/profile/") {
			continue
		}

		// For IDOR, we use the URL path itself as the "param"
		exploit, found := s.testIDORPayloadWithAdaptiveAI(
			ctx,
			subdomain,
			targetURL,
			progressChan,
		)

		if found {
			exploits = append(exploits, exploit)
			break // Early stop - found exploit
		}
	}

	sendProgressUpdate(progressChan, "complete", "IDOR", "", 10, 10)
	return exploits
}

// testPathTraversalVuln tests for Path Traversal with adaptive AI payloads (optimized with parallel hardcoded + adaptive AI)
func (s *Scanner) testPathTraversalVuln(ctx context.Context, subdomain string, urls []string, progressChan chan<- string) []Exploit {
	var exploits []Exploit

	for _, targetURL := range urls {
		// Skip static assets
		if isStaticAsset(targetURL) {
			continue
		}

		parsedURL, err := url.Parse(targetURL)
		if err != nil || parsedURL.RawQuery == "" {
			continue
		}

		params := parsedURL.Query()
		fileParams := []string{"file", "path", "page", "document", "folder", "upload", "download", "dir"}

		// Only test parameters that look like file/path parameters
		for param := range params {
			isFileParam := false
			for _, fp := range fileParams {
				if strings.Contains(strings.ToLower(param), fp) {
					isFileParam = true
					break
				}
			}

			if !isFileParam {
				continue
			}

			exploit, found := s.testPayloadWithAdaptiveAI(
				ctx,
				subdomain,
				targetURL,
				param,
				VulnPathTraversal,
				"Attacker can read arbitrary files from the server",
				progressChan,
			)

			if found {
				exploits = append(exploits, exploit)
				break // Early stop - found exploit for this URL
			}
		}
	}

	sendProgressUpdate(progressChan, "complete", "Path Traversal", "", 10, 10)
	return exploits
}

// testSSRFVuln tests for SSRF with adaptive AI payloads (optimized with parallel hardcoded + adaptive AI)
func (s *Scanner) testSSRFVuln(ctx context.Context, subdomain string, urls []string, progressChan chan<- string) []Exploit {
	var exploits []Exploit

	for _, targetURL := range urls {
		// Skip static assets
		if isStaticAsset(targetURL) {
			continue
		}

		parsedURL, err := url.Parse(targetURL)
		if err != nil || parsedURL.RawQuery == "" {
			continue
		}

		params := parsedURL.Query()
		urlParams := []string{"url", "uri", "redirect", "link", "src", "source", "target", "callback", "proxy"}

		// Only test parameters that look like URL parameters
		for param := range params {
			isURLParam := false
			for _, up := range urlParams {
				if strings.Contains(strings.ToLower(param), up) {
					isURLParam = true
					break
				}
			}

			if !isURLParam {
				continue
			}

			exploit, found := s.testPayloadWithAdaptiveAI(
				ctx,
				subdomain,
				targetURL,
				param,
				VulnSSRF,
				"Attacker can make server access internal services and cloud metadata",
				progressChan,
			)

			if found {
				exploits = append(exploits, exploit)
				break // Early stop - found exploit for this URL
			}
		}
	}

	sendProgressUpdate(progressChan, "complete", "SSRF", "", 10, 10)
	return exploits
}

// testOpenRedirectVuln tests for Open Redirect with adaptive AI payloads (optimized with parallel hardcoded + adaptive AI)
func (s *Scanner) testOpenRedirectVuln(ctx context.Context, subdomain string, urls []string, progressChan chan<- string) []Exploit {
	var exploits []Exploit

	for _, targetURL := range urls {
		// Skip static assets
		if isStaticAsset(targetURL) {
			continue
		}

		parsedURL, err := url.Parse(targetURL)
		if err != nil || parsedURL.RawQuery == "" {
			continue
		}

		params := parsedURL.Query()
		redirectParams := []string{"redirect", "url", "next", "continue", "return", "goto", "callback", "return_to"}

		// Only test parameters that look like redirect parameters
		for param := range params {
			isRedirectParam := false
			for _, rp := range redirectParams {
				if strings.Contains(strings.ToLower(param), rp) {
					isRedirectParam = true
					break
				}
			}

			if !isRedirectParam {
				continue
			}

			exploit, found := s.testPayloadWithAdaptiveAI(
				ctx,
				subdomain,
				targetURL,
				param,
				VulnOpenRedirect,
				"Attacker can redirect users to malicious sites (phishing, malware)",
				progressChan,
			)

			if found {
				exploits = append(exploits, exploit)
				break // Early stop - found exploit for this URL
			}
		}
	}

	sendProgressUpdate(progressChan, "complete", "Open Redirect", "", 10, 10)
	return exploits
}

// testJWTVuln tests for JWT vulnerabilities
func (s *Scanner) testJWTVuln(ctx context.Context, subdomain string, urls []string, progressChan chan<- string) []Exploit {
	sendProgressUpdate(progressChan, "payload", "JWT", "Analyzing JWT tokens...", 1,10)
	// JWT testing implementation would go here
	sendProgressUpdate(progressChan, "complete", "JWT", "", 8,10)
	return []Exploit{}
}

// testJSAnalysisVuln performs JavaScript analysis
func (s *Scanner) testJSAnalysisVuln(ctx context.Context, subdomain string, urls []string, progressChan chan<- string) {
	sendProgressUpdate(progressChan, "payload", "JavaScript Analysis", "Analyzing JavaScript files...", 1,10)
	// JS analysis implementation would go here
	sendProgressUpdate(progressChan, "complete", "JavaScript Analysis", "", 8,10)
}

// Helper functions

// testPayloadWithAdaptiveAI tests payloads with parallel hardcoded + adaptive AI learning
// Returns exploit if found, empty Exploit{} if none found
func (s *Scanner) testPayloadWithAdaptiveAI(
	ctx context.Context,
	subdomain, targetURL, param string,
	vulnType VulnerabilityType,
	impact string,
	progressChan chan<- string,
) (Exploit, bool) {
	// Get 7 hardcoded payloads instantly
	hardcodedPayloads := s.GetHardcodedPayloads(vulnType)

	// Test all 7 hardcoded payloads in parallel
	type testResult struct {
		exploit Exploit
		found   bool
		index   int
	}

	resultChan := make(chan testResult, len(hardcodedPayloads))
	var wg sync.WaitGroup

	// Launch parallel tests for hardcoded payloads
	for i, payload := range hardcodedPayloads {
		wg.Add(1)
		go func(idx int, pload string) {
			defer wg.Done()

			sendProgressUpdate(progressChan, "payload", string(vulnType), pload, idx+1, 10)

			exploit, found := s.testSinglePayload(ctx, subdomain, targetURL, param, pload, vulnType, impact)
			if found {
				sendProgressUpdate(progressChan, "found", string(vulnType), "", idx+1, 10)
				resultChan <- testResult{exploit: exploit, found: true, index: idx}
			}
		}(i, payload)
	}

	// Close channel when all hardcoded tests done
	go func() {
		wg.Wait()
		close(resultChan)
	}()

	// Check if any hardcoded payload succeeded
	for result := range resultChan {
		if result.found {
			return result.exploit, true // Early stop - found exploit!
		}
	}

	// If all 7 hardcoded failed and AI is enabled, try adaptive AI payloads
	if s.aiModel != "" {
		history := &BypassHistory{
			Payloads:             hardcodedPayloads,
			BlockedReasons:       []string{},
			SuccessfulTechniques: []string{},
		}

		// Generate and test AI payloads one by one (adaptive learning)
		for i := 8; i <= 10; i++ {
			aiPayload, err := s.GenerateNextAIPayload(ctx, vulnType, targetURL, history, i, progressChan)
			if err != nil || aiPayload == "" {
				continue // Skip if AI generation fails
			}

			// Test the AI payload immediately
			sendProgressUpdate(progressChan, "payload", string(vulnType), aiPayload, i, 10)
			exploit, found := s.testSinglePayload(ctx, subdomain, targetURL, param, aiPayload, vulnType, impact)

			if found {
				sendProgressUpdate(progressChan, "found", string(vulnType), "", i, 10)
				return exploit, true // Found with AI!
			}

			// Add to history for next AI payload to learn from
			history.Payloads = append(history.Payloads, aiPayload)
		}
	}

	return Exploit{}, false // No exploit found
}

// testSinglePayload tests one payload and returns exploit if successful
func (s *Scanner) testSinglePayload(
	ctx context.Context,
	subdomain, targetURL, param, payload string,
	vulnType VulnerabilityType,
	impact string,
) (Exploit, bool) {
	testURL := s.buildTestURL(targetURL, param, payload)
	req, err := http.NewRequestWithContext(ctx, "GET", testURL, nil)
	if err != nil {
		return Exploit{}, false
	}

	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
	resp, err := s.client.Do(req)
	if err != nil {
		return Exploit{}, false
	}

	body, _ := io.ReadAll(io.LimitReader(resp.Body, 100*1024))
	resp.Body.Close()
	bodyStr := string(body)

	// Analyze response
	success, evidence, reasoning := s.analyzeResponse(ctx, string(vulnType), payload, bodyStr, resp.StatusCode)

	if !success {
		return Exploit{}, false
	}

	// Build exploit based on vulnerability type
	exploit := Exploit{
		Subdomain:     subdomain,
		URL:           testURL,
		VulnType:      vulnType,
		Payload:       payload,
		Method:        "GET",
		StatusCode:    resp.StatusCode,
		Response:      truncate(bodyStr, 500),
		Evidence:      evidence,
		Impact:        impact,
		AIReasoning:   reasoning,
		Verified:      true,
	}

	// Set severity based on type
	switch vulnType {
	case VulnXSS:
		exploit.Severity = s.getXSSSeverity(payload, bodyStr)
		exploit.ExtractedData = s.extractXSSContext(bodyStr, payload)
	case VulnSQLi:
		exploit.Severity = s.getSQLiSeverity(evidence)
		exploit.ExtractedData = s.extractSQLiData(bodyStr)
	case VulnSSRF:
		exploit.Severity = "critical"
	case VulnOpenRedirect:
		exploit.Severity = s.getOpenRedirectSeverity(bodyStr)
	case VulnPathTraversal:
		exploit.Severity = "high"
		exploit.ExtractedData = s.extractPathTraversalData(bodyStr)
	case VulnIDOR:
		exploit.Severity = "high"
	default:
		exploit.Severity = "medium"
	}

	return exploit, true
}

func (s *Scanner) buildTestURL(baseURL, param, payload string) string {
	parsedURL, err := url.Parse(baseURL)
	if err != nil {
		return baseURL
	}

	query := parsedURL.Query()
	query.Set(param, payload)
	parsedURL.RawQuery = query.Encode()
	return parsedURL.String()
}

func (s *Scanner) getXSSSeverity(payload, response string) string {
	if strings.Contains(response, "document.") || strings.Contains(response, "window.") {
		return "high"
	}
	if strings.Contains(response, "<script>"+payload) {
		return "critical"
	}
	return "medium"
}

func (s *Scanner) extractXSSContext(response, payload string) string {
	idx := strings.Index(strings.ToLower(response), strings.ToLower(payload))
	if idx == -1 {
		return "Payload not reflected"
	}

	start := idx - 50
	if start < 0 {
		start = 0
	}
	end := idx + len(payload) + 50
	if end > len(response) {
		end = len(response)
	}

	return response[start:end]
}

func (s *Scanner) extractSQLiContext(response, payload string) string {
	if strings.Contains(response, "mysql") || strings.Contains(response, "syntax error") {
		return "Database error exposed"
	}
	return "SQL injection detected"
}

// isStaticAsset checks if a URL points to a static asset (CSS, JS, images, fonts, etc.)
func isStaticAsset(targetURL string) bool {
	lowerURL := strings.ToLower(targetURL)

	// Static file extensions to skip
	staticExtensions := []string{
		".css", ".js", ".jpg", ".jpeg", ".png", ".gif", ".svg", ".ico",
		".woff", ".woff2", ".ttf", ".eot", ".otf",
		".mp4", ".webm", ".mp3", ".wav",
		".pdf", ".zip", ".tar", ".gz",
		".xml", ".json", // Usually API responses, not exploitable
	}

	for _, ext := range staticExtensions {
		if strings.HasSuffix(lowerURL, ext) {
			return true
		}
	}

	return false
}

// testIDORPayloadWithAdaptiveAI tests IDOR with parallel hardcoded + adaptive AI
// IDOR is special because it replaces URL path segments, not query params
func (s *Scanner) testIDORPayloadWithAdaptiveAI(
	ctx context.Context,
	subdomain, targetURL string,
	progressChan chan<- string,
) (Exploit, bool) {
	// Get 7 hardcoded payloads instantly
	hardcodedPayloads := s.GetHardcodedPayloads(VulnIDOR)

	// Test all 7 hardcoded payloads in parallel
	type testResult struct {
		exploit Exploit
		found   bool
		index   int
	}

	resultChan := make(chan testResult, len(hardcodedPayloads))
	var wg sync.WaitGroup

	// Launch parallel tests for hardcoded payloads
	for i, payload := range hardcodedPayloads {
		wg.Add(1)
		go func(idx int, pload string) {
			defer wg.Done()

			sendProgressUpdate(progressChan, "payload", "IDOR", pload, idx+1, 10)

			// Build IDOR test URL by replacing path segment
			testURL := buildIDORTestURL(targetURL, pload)

			req, err := http.NewRequestWithContext(ctx, "GET", testURL, nil)
			if err != nil {
				return
			}

			req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
			resp, err := s.client.Do(req)
			if err != nil {
				return
			}

			body, _ := io.ReadAll(io.LimitReader(resp.Body, 100*1024))
			resp.Body.Close()
			bodyStr := string(body)

			// Analyze IDOR - check if we got unauthorized access (200 OK)
			if resp.StatusCode == 200 && len(body) > 100 {
				sendProgressUpdate(progressChan, "found", "IDOR", "", idx+1, 10)
				exploit := Exploit{
					Subdomain:     subdomain,
					URL:           testURL,
					VulnType:      VulnIDOR,
					Payload:       pload,
					Method:        "GET",
					StatusCode:    resp.StatusCode,
					Response:      truncate(bodyStr, 500),
					Evidence:      "Unauthorized access to resource",
					Impact:        "Attacker can access other users' data",
					Verified:      true,
					Severity:      "high",
				}
				resultChan <- testResult{exploit: exploit, found: true, index: idx}
			}
		}(i, payload)
	}

	// Close channel when all hardcoded tests done
	go func() {
		wg.Wait()
		close(resultChan)
	}()

	// Check if any hardcoded payload succeeded
	for result := range resultChan {
		if result.found {
			return result.exploit, true // Early stop - found exploit!
		}
	}

	// If all 7 hardcoded failed and AI is enabled, try adaptive AI payloads
	if s.aiModel != "" {
		history := &BypassHistory{
			Payloads:             hardcodedPayloads,
			BlockedReasons:       []string{},
			SuccessfulTechniques: []string{},
		}

		// Generate and test AI payloads one by one (adaptive learning)
		for i := 8; i <= 10; i++ {
			aiPayload, err := s.GenerateNextAIPayload(ctx, VulnIDOR, targetURL, history, i, progressChan)
			if err != nil || aiPayload == "" {
				continue // Skip if AI generation fails
			}

			// Test the AI payload immediately
			sendProgressUpdate(progressChan, "payload", "IDOR", aiPayload, i, 10)

			testURL := buildIDORTestURL(targetURL, aiPayload)
			req, err := http.NewRequestWithContext(ctx, "GET", testURL, nil)
			if err != nil {
				history.Payloads = append(history.Payloads, aiPayload)
				continue
			}

			req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
			resp, err := s.client.Do(req)
			if err != nil {
				history.Payloads = append(history.Payloads, aiPayload)
				continue
			}

			body, _ := io.ReadAll(io.LimitReader(resp.Body, 100*1024))
			resp.Body.Close()
			bodyStr := string(body)

			// Check for successful IDOR
			if resp.StatusCode == 200 && len(body) > 100 {
				sendProgressUpdate(progressChan, "found", "IDOR", "", i, 10)
				exploit := Exploit{
					Subdomain:     subdomain,
					URL:           testURL,
					VulnType:      VulnIDOR,
					Payload:       aiPayload,
					Method:        "GET",
					StatusCode:    resp.StatusCode,
					Response:      truncate(bodyStr, 500),
					Evidence:      "Unauthorized access to resource (AI-generated payload)",
					Impact:        "Attacker can access other users' data",
					Verified:      true,
					Severity:      "high",
				}
				return exploit, true
			}

			// Add to history for next AI payload to learn from
			history.Payloads = append(history.Payloads, aiPayload)
		}
	}

	return Exploit{}, false // No exploit found
}

// buildIDORTestURL builds IDOR test URL by replacing path segments
func buildIDORTestURL(baseURL, payload string) string {
	// Replace common IDOR patterns
	if strings.Contains(baseURL, "/users/") {
		// Replace the ID after /users/
		parts := strings.Split(baseURL, "/users/")
		if len(parts) >= 2 {
			// Keep everything before /users/, then add payload
			afterUsers := strings.Split(parts[1], "/")
			afterUsers[0] = payload // Replace the ID
			return parts[0] + "/users/" + strings.Join(afterUsers, "/")
		}
	}

	if strings.Contains(baseURL, "/api/") {
		// Try to replace ID patterns in API paths
		parts := strings.Split(baseURL, "/")
		for i, part := range parts {
			// Look for numeric IDs or UUIDs
			if len(part) > 0 && (isNumeric(part) || isUUID(part)) {
				parts[i] = payload
				return strings.Join(parts, "/")
			}
		}
	}

	// Fallback: append payload to URL
	return baseURL + "/" + payload
}

// isNumeric checks if a string is numeric
func isNumeric(s string) bool {
	for _, c := range s {
		if c < '0' || c > '9' {
			return false
		}
	}
	return len(s) > 0
}

// isUUID checks if a string looks like a UUID
func isUUID(s string) bool {
	return len(s) == 36 && strings.Count(s, "-") == 4
}

// getSQLiSeverity determines SQL injection severity based on evidence
func (s *Scanner) getSQLiSeverity(evidence string) string {
	lowerEvidence := strings.ToLower(evidence)

	// Critical: Database enumeration, data extraction
	if strings.Contains(lowerEvidence, "table") ||
		strings.Contains(lowerEvidence, "column") ||
		strings.Contains(lowerEvidence, "database") ||
		strings.Contains(lowerEvidence, "version") {
		return "critical"
	}

	// High: Error-based or time-based confirmation
	if strings.Contains(lowerEvidence, "error") ||
		strings.Contains(lowerEvidence, "syntax") ||
		strings.Contains(lowerEvidence, "mysql") ||
		strings.Contains(lowerEvidence, "postgresql") {
		return "high"
	}

	return "critical" // Default to critical for SQLi
}

// getOpenRedirectSeverity determines open redirect severity
func (s *Scanner) getOpenRedirectSeverity(response string) string {
	lowerResp := strings.ToLower(response)

	// High: JavaScript protocol (XSS-like)
	if strings.Contains(lowerResp, "javascript:") {
		return "high"
	}

	// Medium: External redirect
	if strings.Contains(lowerResp, "evil.com") ||
		strings.Contains(lowerResp, "location:") {
		return "medium"
	}

	return "medium" // Default for open redirect
}

// extractPathTraversalData extracts evidence from path traversal response
func (s *Scanner) extractPathTraversalData(response string) string {
	// Check for /etc/passwd content
	if strings.Contains(response, "root:x:") ||
		strings.Contains(response, "/bin/bash") ||
		strings.Contains(response, "/sbin/nologin") {
		return "Unix /etc/passwd file detected"
	}

	// Check for Windows hosts file
	if strings.Contains(response, "127.0.0.1") &&
		strings.Contains(response, "localhost") {
		return "Windows hosts file detected"
	}

	// Check for other system files
	if strings.Contains(response, "boot.ini") ||
		strings.Contains(response, "[boot loader]") {
		return "Windows boot.ini detected"
	}

	return "System file access detected"
}
